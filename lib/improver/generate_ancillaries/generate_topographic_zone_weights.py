# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# (C) British Crown Copyright 2017 Met Office.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of the copyright holder nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
"""Module for generating the weights for topographic zones."""

from cf_units import Unit
import numpy as np
from scipy import interpolate
import iris

from improver.generate_ancillaries.generate_ancillary import (
    GenerateOrographyBandAncils, _make_mask_cube)


class GenerateTopographicZoneWeights(object):

    """Generate weights generated by determining where the orography lies
    within the topographic zones."""

    def __init__(self):
        """Initialise the class."""
        pass

    def add_weight_to_upper_adjacent_band(
            self, orography_band, midpoint, band_number, weights,
            max_band_number):
        """Once we have found the weight for a point in one band,
        we need to add 1-weight to the band above or below,
        depending on the altitude of the point.
        If the point is in the lowest band and below the midpoint of this
        band then we need to put a weight of one at this point in the
        lowest band as there is no other band to weight with.
        The same principle is applied to the top band.

        Args:
            orography_band (float):
                All points within the orography band of interest.
            midpoint (float):
                The midpoint of the band the point is in.
            band_number (float):
                The index that corrresponds to the band in a cube with
                multiple topography bands.
            weights (float):
                The weight we have already calculated for the points within the
                orography band.
            max_band_number (float):
                The highest index for the bands coordinate in the weights.

        Returns:
            (tuple):

        """
        print "original weights = ", weights
        print "band_number = ", band_number
        weights_for_adjacent_band = np.full(weights.shape, np.nan)

        # For points above the midpoint.
        mask_y, mask_x = np.where(orography_band > midpoint)
        if band_number == max_band_number:
            weights_for_adjacent_band[mask_y, mask_x] = 1.0
            adjacent_band_number = band_number
        else:
            weights_for_adjacent_band[mask_y, mask_x] = (
                1 - weights[mask_y, mask_x])
            adjacent_band_number = band_number+1
        return weights_for_adjacent_band, adjacent_band_number

    def add_weight_to_lower_adjacent_band(
            self, orography_band, midpoint, band_number, weights,
            max_band_number):
        """Once we have found the weight for a point in one band,
        we need to add 1-weight to the band above or below,
        depending on the altitude of the point.
        If the point is in the lowest band and below the midpoint of this
        band then we need to put a weight of one at this point in the
        lowest band as there is no other band to weight with.
        The same principle is applied to the top band.

        Args:
            orography_band (float):
                All points within the orography band of interest.
            midpoint (float):
                The midpoint of the band the point is in.
            band_number (float):
                The index that corrresponds to the band in a cube with
                multiple topography bands.
            weights (float):
                The weight we have already calculated for the points within the
                orography band.
            max_band_number (float):
                The highest index for the bands coordinate in the weights.

        Returns:
            (tuple):

        """
        print "original weights = ", weights
        print "band_number = ", band_number
        weights_for_adjacent_band = np.full(weights.shape, np.nan)

        # For points below the midpoint.
        mask_y, mask_x = np.where(orography_band < midpoint)
        if band_number == 0:
            weights_for_adjacent_band[mask_y, mask_x] = 1.0
            adjacent_band_number = band_number
        else:
            weights_for_adjacent_band[mask_y, mask_x] = (
                1 - weights[mask_y, mask_x])
            adjacent_band_number = band_number-1
        return weights_for_adjacent_band, adjacent_band_number

    def calculate_weights(self, points, midpoint, band):
        """Calculate weights

        Args:
            points (float or numpy array):
                e.g. 125 or np.array([125, 140]).
            band (list):
                e.g. [100., 200.]
        """
        weights = [0.5, 1.0, 0.5]
        band_points = [band[0], midpoint, band[1]]
        interpolation_function = interpolate.interp1d(
            band_points, weights, fill_value="extrapolate")
        interpolated_weights = interpolation_function(points)
        print "interpolated_weights = ", interpolated_weights
        return interpolated_weights

    def process(self, orography, landmask, thresholds_dict):
        """Calculate the weights depending upon where the orography point is
        within the topographic zones.

        Args:
            orography (cube):
                orography on standard grid.
            landmask (cube):
                land mask on standard grid.
            thresholds_dict (dict):
                definition of orography bands required.

        Returns:
            weights (cube):
                Cube containing the weights depending upon where the orography
                point is within the topographic zones.

        """
        # Loop through data points within orography. Determine which band the data point
        # is compared to the bounds provided in the thresholds_dict.
        # Use a function to generate weights between one midpoint and another midpoint,
        # where the edge of a band is 0.5. Mask data which are sea points.

        # Check that orography is a 2d cube.
        if len(orography.shape) != 2:
            msg = ("The input orography cube should be two-dimensional."
                   "The input orography cube has {} dimensions".format(
                       len(orography.shape)))
            raise InvalidCubeError(msg)

        print "landmask = ", landmask
        print "landmask = ", landmask.data
        print "orography = ", orography
        #landmask = landmask[:2, :2]
        #orography = orography[:2, :2]

        # Create a cube into which values can be inserted.
        mask_data = GenerateOrographyBandAncils().sea_mask(
            landmask.data, np.zeros(orography.shape))
        print "mask_data = ", mask_data

        # Find bands and midpoints from bounds
        bands = thresholds_dict["land"]["bounds"]
        print "bands = ", bands

        # Create topographic_zone_cube first, so that a cube is created for
        # each band. This will allow the data for neighbouring bands to be
        # put into the cube. 
        topographic_zone_cubes = iris.cube.CubeList([])
        for band in bands:
            topographic_zone_cube = (
                _make_mask_cube(mask_data, "land", orography.coords(), band))
            topographic_zone_cubes.append(topographic_zone_cube)
        topographic_zone_cube = topographic_zone_cubes.concatenate_cube()

        # Insert the appropriate weights into the topographic zone cube.
        for band_number, band in enumerate(bands):
            print "Looping for band = ", band
            mask_y, mask_x = (
                np.where((orography.data > band[0]) & (orography.data <= band[1])))
            orography_band = np.full(orography.shape, np.nan)
            orography_band[mask_y, mask_x] = orography.data[mask_y, mask_x]
            midpoint = np.mean(band)
            weights = self.calculate_weights(orography_band, midpoint, band)
            topographic_zone_cube.data[band_number, ...] = weights

            weights_in_adjacent_band, adjacent_band_number = (
                self.add_weight_to_lower_adjacent_band(
                    orography_band, midpoint, band_number, weights, len(bands)-1))
            topographic_zone_cube.data[adjacent_band_number, ...] = weights_in_adjacent_band

            weights_in_adjacent_band, adjacent_band_number = (
                self.add_weight_to_upper_adjacent_band(
                    orography_band, midpoint, band_number, weights, len(bands)-1))
            topographic_zone_cube.data[band_number, ...] = weights_in_adjacent_band

        topographic_zone_cube.rename("Topographic_zone_weights")
        topographic_zone_cube.units = Unit("1")
        print "topographic_zone_cube = ", topographic_zone_cube.data
        return topographic_zone_cube
