# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# (C) British Crown Copyright 2017 Met Office.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of the copyright holder nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
"""Module for generating the weights for topographic zones."""

from cf_units import Unit
import numpy as np

from improver.blending.weights.ChooseDefaultWeightsTriangular import (
    calculate_triangular_weight)
from improver.generate_ancillary import GenerateOrographyBandAncils


class generate_topographic_zone_weights(object):

    """Generate weights generated by determining where the orography lies
    within the topographic zones."""

    def __init__(self):
        """Initialise the class."""
        pass

    @staticmethod
    def find_band_number(point, bands):
        """Find which band the point falls in.
        bands has the form [[0,1],[1,2],[2,3]].

        Args:
            point (float):
                Point to use for determining which band the point is within.
            bands (list):
                List of lists defining the bands to search to determine
                which band the point is within.
        """
        for i, band in enumerate(bands):
            if point > band[0] and point <= band[1]:
                return i

    @staticmethod
    def add_weight_to_adjacent_band(
            point, midpoint, band_no, weight, max_band_no):
        """Once we have found the weight for a point in one band,
        we need to add 1-weight to the band above or below,
        depending on the altitude of the point.
        If the point is in the lowest band and below the midpoint of this
        band then we need to put a weight of one at this point in the
        lowest band as there is no other band to weight with.
        The same principle is applied to the top band.

        Args:
            point (float):
                The altitude of the point of interest.
            midpoint (float):
                The midpoint of the band the point is in.
            band_no (float):
                The index that corrresponds to the band in a cube with
                multiple topography bands.
            weight (float):
                The weight we have already calculated at the point of interest.
            max_band_no (float):
                The highest index for the bands coordinate in the weights.

        Returns:
            (tuple):

        """
        if point < midpoint:
            if band_no == 0:
                weight;l = 1.0
                adjacent_band_number = band_no
            else:
                weight = 1 - weight
                adjacent_band_number = band_no-1
        elif point > midpoint:
            if band_no == max_band_no:
                weight = 1.0
                adjacent_band_number = band_no
            else:
                weight = 1 - weight
                adjacent_band_number = band_no+1
        return weight, adjacent_band_numberl


    def calculate_weights(self, point, midpoint, band):
        """

        Args:
            point (float):
                e.g. 125.
            midpoint (float):
                e.g. 150.
            band (list):
                e.g. [100., 200.]
        """
        weights = [0.5, 1.0, 0.5]
        points = [band[0], midpoint, band[1]]
        weight = np.interp(point, points, weights)
        return weight

    @staticmethod
    def calculate_weights_array(weights, bands, midpoints, orography_slice):
        """Fill in the weights array based on the topography bands and the
           input orography.

        Args:
            weights
                The weights array to be filled in, dimensions
               (no of bands, x, y).
            bands
                The bounds from the topographic bands coordinate of the
                mask or neighbourhooded cube.
            midpoints
                The points from the topographic bands coordinate of the
                mask or neighbourhooded cube.
            orography_slice (iris.cube.Cube):
                The orography data array.

        Returns:
            weights
                The weights array to be filled in, dimensions
               (no of bands, x, y).
        """
        point = orography_slice.data
        band_no = find_band_number(point, bands)
        weight = calculate_weights(point, midpoints[band_no])
        add_weight_to_adjacent_band(
            point, midpoints[band_no], band_no, weight, len(bands)-1)
        weights = [weight, weight_in_adjacent_band]
        band_numbers = [band_no, adjacent_band_number]
        return weights, band_numbers

    @staticmethod
    def process(orography, landmask, threshold_dict):
        """Calculate the weights depending upon where the orography point is
        within the topographic zones.

        Args:
            orography (cube):
                orography on standard grid.
            landmask (cube):
                land mask on standard grid.
            threshold_dict (dict):
                definition of orography bands required.

        Returns:
            weights (cube):
                Cube containing the weights depending upon where the orography
                point is within the topographic zones.

        """
# Loop through data points within orography. Determine which band the data point
# is compared to the bounds provided in the thresholds_dict.
# Use a function to generate weights between one midpoint and another midpoint,
# where the edge of a band is 0.5. Mask data which are sea points.

        # Check that orography is a 2d cube.
        if len(orography.shape) != 2:
            msg = ("The input orography cube should be two-dimensional."
                   "The input orography cube has {} dimensions".format(
                       len(orography.shape)))
            raise InvalidCubeError(msg)

        # Create a cube into which values can be inserted.
        mask_data = sea_mask(standard_landmask.data, orography)
        topographic_zone_cube = (
            _make_mask_cube(mask_data, "land", orography.coords, bands))

        # Find bands and midpoints from bounds
        bands = thresholds_dict["land"]["bounds"]
        midpoints = np.mean(bands, axis=1)

        orography_slices = orography.slices(
            [orography.coord(axis="y"), orography.coord(axis="x")])

        topographic_zone_cubes = iris.cube.CubeList([])
        for orography_slice in orography_slices:
            weights, band_numbers = calculate_weights_array(
                weights, bands, midpoints, orography_slice)
            topographic_zone_cube[band_numbers, ...].data = weights
            topographic_zone_cubes.append(topographic_zone_cube)
        topographic_zone_cube = topographic_zone_cubes.concatenate_cube()

        topographic_zone_cube.rename("Topographic_zone_weights")
        topographic_zone_cube.units = Unit("1")
        return weights
