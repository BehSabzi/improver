# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# (C) British Crown Copyright 2017 Met Office.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of the copyright holder nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
"""Module for generating the weights for topographic zones."""

from cf_units import Unit
import numpy as np
import iris

from improver.generate_ancillaries.generate_ancillary import (
    GenerateOrographyBandAncils, _make_mask_cube)


class GenerateTopographicZoneWeights(object):

    """Generate weights generated by determining where the orography lies
    within the topographic zones."""

    def __init__(self):
        """Initialise the class."""
        pass

    def find_band_number(self, point, bands):
        """Find which band the point falls in.
        bands has the form [[0,1],[1,2],[2,3]].

        Args:
            point (float):
                Point to use for determining which band the point is within.
            bands (list):
                List of lists defining the bands to search to determine
                which band the point is within.
        """
        for i, band in enumerate(bands):
            if point > band[0] and point <= band[1]:
                return i

    def add_weight_to_adjacent_band(
            self, point, midpoint, band_no, weight, max_band_no):
        """Once we have found the weight for a point in one band,
        we need to add 1-weight to the band above or below,
        depending on the altitude of the point.
        If the point is in the lowest band and below the midpoint of this
        band then we need to put a weight of one at this point in the
        lowest band as there is no other band to weight with.
        The same principle is applied to the top band.

        Args:
            point (float):
                The altitude of the point of interest.
            midpoint (float):
                The midpoint of the band the point is in.
            band_no (float):
                The index that corrresponds to the band in a cube with
                multiple topography bands.
            weight (float):
                The weight we have already calculated at the point of interest.
            max_band_no (float):
                The highest index for the bands coordinate in the weights.

        Returns:
            (tuple):

        """
        if point < midpoint:
            if band_no == 0:
                weight = 1.0
                adjacent_band_number = band_no
            else:
                weight = 1 - weight
                adjacent_band_number = band_no-1
        elif point > midpoint:
            if band_no == max_band_no:
                weight = 1.0
                adjacent_band_number = band_no
            else:
                weight = 1 - weight
                adjacent_band_number = band_no+1
        return weight, adjacent_band_number


    def calculate_weights(self, point, midpoint, band):
        """

        Args:
            point (float):
                e.g. 125.
            midpoint (float):
                e.g. 150.
            band (list):
                e.g. [100., 200.]
        """
        weights = [0.5, 1.0, 0.5]
        points = [band[0], midpoint, band[1]]
        weight = np.interp(point, points, weights)
        return weight

    def calculate_weights_array(self, orography_slice, bands, midpoints):
        """Fill in the weights array based on the topography bands and the
           input orography.

        Args:
            orography_slice (iris.cube.Cube):
                The orography data array.
            bands
                The bounds from the topographic bands coordinate of the
                mask or neighbourhooded cube.
            midpoints
                The points from the topographic bands coordinate of the
                mask or neighbourhooded cube.

        Returns:
            weights (numpy array)
                The weights array to be filled in, dimensions
               (no of bands, x, y).
            band_numbers ():
                The band numbers.
        """
        print "orography_slice = ", orography_slice
        print "orography_slice.data = ", orography_slice.data
        point = orography_slice.data
        band_no = self.find_band_number(point, bands)
        weight = self.calculate_weights(
            point, midpoints[band_no], bands[band_no])
        weight_in_adjacent_band, adjacent_band_number = (
            self.add_weight_to_adjacent_band(
                point, midpoints[band_no], band_no, weight, len(bands)-1))
        weights = [weight, weight_in_adjacent_band]
        band_numbers = [band_no, adjacent_band_number]
        print "weights = ", weights
        print "band_numbers = ", band_numbers
        return weights, band_numbers

    def process(self, orography, landmask, thresholds_dict):
        """Calculate the weights depending upon where the orography point is
        within the topographic zones.

        Args:
            orography (cube):
                orography on standard grid.
            landmask (cube):
                land mask on standard grid.
            thresholds_dict (dict):
                definition of orography bands required.

        Returns:
            weights (cube):
                Cube containing the weights depending upon where the orography
                point is within the topographic zones.

        """
        # Loop through data points within orography. Determine which band the data point
        # is compared to the bounds provided in the thresholds_dict.
        # Use a function to generate weights between one midpoint and another midpoint,
        # where the edge of a band is 0.5. Mask data which are sea points.

        # Check that orography is a 2d cube.
        if len(orography.shape) != 2:
            msg = ("The input orography cube should be two-dimensional."
                   "The input orography cube has {} dimensions".format(
                       len(orography.shape)))
            raise InvalidCubeError(msg)

        print "landmask = ", landmask
        print "orography = ", orography
        #landmask = landmask[:2, :2]
        #orography = orography[:2, :2]

        # Create a cube into which values can be inserted.
        mask_data = GenerateOrographyBandAncils().sea_mask(
            landmask.data, orography.data)
        print "mask_data = ", mask_data

        # Find bands and midpoints from bounds
        bands = thresholds_dict["land"]["bounds"]
        midpoints = np.mean(bands, axis=1)
        print "bands = ", bands

        # Create topographic_zone_cube
        topographic_zone_cubes = iris.cube.CubeList([])
        for band in bands:
            topographic_zone_cubes.append(
                _make_mask_cube(mask_data, "land", orography.coords(), band))
        topographic_zone_cube = topographic_zone_cubes.concatenate_cube()

        print "topographic_zone_cube = ", topographic_zone_cube

        # Create 2d orography slices.
        orography_slices = orography.slices([])
        topographic_zone_slices = (
            topographic_zone_cube.slices(["topographic_zone"]))

        topographic_zone_cubes = iris.cube.CubeList([])
        for orography_slice, topographic_zone_slice in zip(orography_slices, topographic_zone_slices):
            print "orography"
            weights, band_numbers = self.calculate_weights_array(
                orography_slice, bands, midpoints)
            topographic_zone_slice[band_numbers].data = weights
            topographic_zone_cubes.append(topographic_zone_slice)
        topographic_zone_cube = topographic_zone_cubes.merge_cube()

        topographic_zone_cube.rename("Topographic_zone_weights")
        topographic_zone_cube.units = Unit("1")
        print "topographic_zone_cube = ", topographic_zone_cube.data
        return topographic_zone_cube
