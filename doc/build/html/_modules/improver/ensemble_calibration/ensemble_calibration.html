<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>improver.ensemble_calibration.ensemble_calibration &#8212; Improver  documentation</title>
    
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="top" title="Improver  documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Improver  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for improver.ensemble_calibration.ensemble_calibration</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># (C) British Crown Copyright 2017 Met Office.</span>
<span class="c1"># All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># * Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#   list of conditions and the following disclaimer.</span>
<span class="c1">#</span>
<span class="c1"># * Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#   this list of conditions and the following disclaimer in the documentation</span>
<span class="c1">#   and/or other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="c1"># * Neither the name of the copyright holder nor the names of its</span>
<span class="c1">#   contributors may be used to endorse or promote products derived from</span>
<span class="c1">#   this software without specific prior written permission.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="c1"># AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="c1"># IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="c1"># ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</span>
<span class="c1"># LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="c1"># CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="c1"># SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="c1"># INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="c1"># CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="c1"># ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="c1"># POSSIBILITY OF SUCH DAMAGE.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines all the &quot;plugins&quot; specific for ensemble calibration.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">stats</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">minimize</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">norm</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">cf_units</span> <span class="k">as</span> <span class="nn">unit</span>
<span class="kn">import</span> <span class="nn">iris</span>

<span class="kn">from</span> <span class="nn">improver.ensemble_calibration.ensemble_calibration_utilities</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">convert_cube_data_to_2d</span><span class="p">,</span> <span class="n">concatenate_cubes</span><span class="p">,</span> <span class="n">rename_coordinate</span><span class="p">,</span>
    <span class="n">check_predictor_of_mean_flag</span><span class="p">)</span>


<div class="viewcode-block" id="ContinuousRankedProbabilityScoreMinimisers"><a class="viewcode-back" href="../../../improver.ensemble_calibration.html#improver.ensemble_calibration.ensemble_calibration.ContinuousRankedProbabilityScoreMinimisers">[docs]</a><span class="k">class</span> <span class="nc">ContinuousRankedProbabilityScoreMinimisers</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Minimise the Continuous Ranked Probability Score (CRPS)</span>

<span class="sd">    Calculate the optimised coefficients for minimising the CRPS based on</span>
<span class="sd">    assuming a particular probability distribution for the phenomenon being</span>
<span class="sd">    minimised.</span>

<span class="sd">    The number of coefficients that will be optimised depend upon the initial</span>
<span class="sd">    guess.</span>

<span class="sd">    Minimisation is performed using the Nelder-Mead algorithm for 200</span>
<span class="sd">    iterations to limit the computational expense.</span>
<span class="sd">    Note that the BFGS algorithm was initially trialled but had a bug</span>
<span class="sd">    in comparison to comparative results generated in R.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Maximum iterations for minimisation using Nelder-Mead.</span>
    <span class="n">MAX_ITERATIONS</span> <span class="o">=</span> <span class="mi">200</span>

    <span class="c1"># The tolerated percentage change for the final iteration when</span>
    <span class="c1"># performing the minimisation.</span>
    <span class="n">TOLERATED_PERCENTAGE_CHANGE</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="c1"># An arbitrary value set if an infinite value is detected</span>
    <span class="c1"># as part of the minimisation.</span>
    <span class="n">BAD_VALUE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mi">999999</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Dictionary containing the minimisation functions, which will</span>
        <span class="c1"># be used, depending upon the distribution, which is requested.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minimisation_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_crps_minimiser</span><span class="p">,</span>
            <span class="s2">&quot;truncated gaussian&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncated_normal_crps_minimiser</span><span class="p">}</span>

<div class="viewcode-block" id="ContinuousRankedProbabilityScoreMinimisers.crps_minimiser_wrapper"><a class="viewcode-back" href="../../../improver.ensemble_calibration.html#improver.ensemble_calibration.ensemble_calibration.ContinuousRankedProbabilityScoreMinimisers.crps_minimiser_wrapper">[docs]</a>    <span class="k">def</span> <span class="nf">crps_minimiser_wrapper</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">forecast_predictor</span><span class="p">,</span> <span class="n">truth</span><span class="p">,</span> <span class="n">forecast_var</span><span class="p">,</span>
            <span class="n">predictor_of_mean_flag</span><span class="p">,</span> <span class="n">distribution</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to pass a given minimisation function to the scipy minimize</span>
<span class="sd">        function to estimate optimised values for the coefficients.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        initial_guess : List</span>
<span class="sd">            List of optimised coefficients.</span>
<span class="sd">            Order of coefficients is [c, d, a, b].</span>
<span class="sd">        forecast_predictor : Iris cube</span>
<span class="sd">            Cube containing the fields to be used as the predictor,</span>
<span class="sd">            either the ensemble mean or the ensemble members.</span>
<span class="sd">        truth : Iris cube</span>
<span class="sd">            Cube containing the field, which will be used as truth.</span>
<span class="sd">        forecast_var : Iris cube</span>
<span class="sd">            Cube containg the field containing the ensemble variance.</span>
<span class="sd">        predictor_of_mean_flag : String</span>
<span class="sd">            String to specify the input to calculate the calibrated mean.</span>
<span class="sd">            Currently the ensemble mean (&quot;mean&quot;) and the ensemble members</span>
<span class="sd">            (&quot;members&quot;) are supported as the predictors.</span>
<span class="sd">        distribution : String</span>
<span class="sd">            String used to access the appropriate minimisation function</span>
<span class="sd">            within self.minimisation_dict.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        optimised_coeffs : List</span>
<span class="sd">            List of optimised coefficients.</span>
<span class="sd">            Order of coefficients is [c, d, a, b].</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">calculate_percentage_change_in_last_iteration</span><span class="p">(</span><span class="n">allvecs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculate the percentage change that has occurred within</span>
<span class="sd">            the last iteration of the minimisation. If the percentage change</span>
<span class="sd">            between the last iteration and the last-but-one iteration exceeds</span>
<span class="sd">            the threshold, a warning message is printed.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            allvecs : List</span>
<span class="sd">                List of numpy arrays containing the optimised coefficients,</span>
<span class="sd">                after each iteration.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">last_iteration_percentage_change</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span>
                <span class="p">(</span><span class="n">allvecs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">allvecs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">allvecs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="mi">100</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">last_iteration_percentage_change</span> <span class="o">&gt;</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">TOLERATED_PERCENTAGE_CHANGE</span><span class="p">)):</span>
                <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">suppress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">The final iteration resulted in a percentage change &quot;</span>
                       <span class="s2">&quot;that is greater than the accepted threshold of 5% &quot;</span>
                       <span class="s2">&quot;i.e. </span><span class="si">{}</span><span class="s2">. &quot;</span>
                       <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">A satisfactory minimisation has not been achieved. &quot;</span>
                       <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Last iteration: </span><span class="si">{}</span><span class="s2">, &quot;</span>
                       <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Last-but-one iteration: </span><span class="si">{}</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Absolute difference: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                           <span class="n">last_iteration_percentage_change</span><span class="p">,</span> <span class="n">allvecs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                           <span class="n">allvecs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">allvecs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">allvecs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">minimisation_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimisation_dict</span><span class="p">[</span><span class="n">distribution</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Distribution requested </span><span class="si">{}</span><span class="s2"> is not supported in </span><span class="si">{}</span><span class="s2">&quot;</span>
                   <span class="s2">&quot;Error message is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                       <span class="n">distribution</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimisation_dict</span><span class="p">,</span> <span class="n">err</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Ensure predictor_of_mean_flag is valid.</span>
        <span class="n">check_predictor_of_mean_flag</span><span class="p">(</span><span class="n">predictor_of_mean_flag</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">predictor_of_mean_flag</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]:</span>
            <span class="n">forecast_predictor_data</span> <span class="o">=</span> <span class="n">forecast_predictor</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">truth_data</span> <span class="o">=</span> <span class="n">truth</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">forecast_var_data</span> <span class="o">=</span> <span class="n">forecast_var</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">predictor_of_mean_flag</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;members&quot;</span><span class="p">]:</span>
            <span class="n">truth_data</span> <span class="o">=</span> <span class="n">truth</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">forecast_predictor_data</span> <span class="o">=</span> <span class="n">convert_cube_data_to_2d</span><span class="p">(</span>
                <span class="n">forecast_predictor</span><span class="p">)</span>
            <span class="n">forecast_var_data</span> <span class="o">=</span> <span class="n">forecast_var</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="n">initial_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">initial_guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">forecast_predictor_data</span> <span class="o">=</span> <span class="n">forecast_predictor_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">forecast_var_data</span> <span class="o">=</span> <span class="n">forecast_var_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">truth_data</span> <span class="o">=</span> <span class="n">truth_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">sqrt_pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">optimised_coeffs</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
            <span class="n">minimisation_function</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">forecast_predictor_data</span><span class="p">,</span> <span class="n">truth_data</span><span class="p">,</span>
                  <span class="n">forecast_var_data</span><span class="p">,</span> <span class="n">sqrt_pi</span><span class="p">,</span> <span class="n">predictor_of_mean_flag</span><span class="p">),</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Nelder-Mead&quot;</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;maxiter&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">MAX_ITERATIONS</span><span class="p">,</span> <span class="s2">&quot;return_all&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">optimised_coeffs</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Minimisation did not result in convergence after &quot;</span>
                   <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> iterations. </span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">MAX_ITERATIONS</span><span class="p">,</span> <span class="n">optimised_coeffs</span><span class="o">.</span><span class="n">message</span><span class="p">))</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">calculate_percentage_change_in_last_iteration</span><span class="p">(</span><span class="n">optimised_coeffs</span><span class="o">.</span><span class="n">allvecs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">optimised_coeffs</span><span class="o">.</span><span class="n">x</span></div>

<div class="viewcode-block" id="ContinuousRankedProbabilityScoreMinimisers.normal_crps_minimiser"><a class="viewcode-back" href="../../../improver.ensemble_calibration.html#improver.ensemble_calibration.ensemble_calibration.ContinuousRankedProbabilityScoreMinimisers.normal_crps_minimiser">[docs]</a>    <span class="k">def</span> <span class="nf">normal_crps_minimiser</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">forecast_predictor</span><span class="p">,</span> <span class="n">truth</span><span class="p">,</span> <span class="n">forecast_var</span><span class="p">,</span>
            <span class="n">sqrt_pi</span><span class="p">,</span> <span class="n">predictor_of_mean_flag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Minimisation function to calculate coefficients based on minimising the</span>
<span class="sd">        CRPS for a normal distribution.</span>

<span class="sd">        Scientific Reference:</span>
<span class="sd">        Gneiting, T. et al., 2005.</span>
<span class="sd">        Calibrated Probabilistic Forecasting Using Ensemble Model Output</span>
<span class="sd">        Statistics and Minimum CRPS Estimation.</span>
<span class="sd">        Monthly Weather Review, 133(5), pp.1098-1118.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        initial_guess : List</span>
<span class="sd">            List of optimised coefficients.</span>
<span class="sd">            Order of coefficients is [c, d, a, b].</span>
<span class="sd">        forecast_predictor : Numpy array</span>
<span class="sd">            Data to be used as the predictor,</span>
<span class="sd">            either the ensemble mean or the ensemble members.</span>
<span class="sd">        truth : Numpy array</span>
<span class="sd">            Data to be used as truth.</span>
<span class="sd">        forecast_var : Numpy array</span>
<span class="sd">            Ensemble variance data.</span>
<span class="sd">        sqrt_pi : Numpy array</span>
<span class="sd">            Square root of Pi</span>
<span class="sd">        predictor_of_mean_flag : String</span>
<span class="sd">            String to specify the input to calculate the calibrated mean.</span>
<span class="sd">            Currently the ensemble mean (&quot;mean&quot;) and the ensemble members</span>
<span class="sd">            (&quot;members&quot;) are supported as the predictors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : Float</span>
<span class="sd">            Minimum value for the CRPS achieved.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">predictor_of_mean_flag</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">initial_guess</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="n">predictor_of_mean_flag</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;members&quot;</span><span class="p">]:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">initial_guess</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">+</span><span class="p">(</span><span class="n">initial_guess</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

        <span class="n">new_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">truth</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">all_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">new_col</span><span class="p">,</span> <span class="n">forecast_predictor</span><span class="p">))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">all_data</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">initial_guess</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">initial_guess</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">forecast_var</span><span class="p">)</span>
        <span class="n">xz</span> <span class="o">=</span> <span class="p">(</span><span class="n">truth</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="n">sigma</span>
        <span class="n">normal_cdf</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">xz</span><span class="p">)</span>
        <span class="n">normal_pdf</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">xz</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span>
            <span class="n">sigma</span> <span class="o">*</span> <span class="p">(</span><span class="n">xz</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">normal_cdf</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">normal_pdf</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sqrt_pi</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mu</span><span class="o">/</span><span class="n">sigma</span><span class="p">)):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BAD_VALUE</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="ContinuousRankedProbabilityScoreMinimisers.truncated_normal_crps_minimiser"><a class="viewcode-back" href="../../../improver.ensemble_calibration.html#improver.ensemble_calibration.ensemble_calibration.ContinuousRankedProbabilityScoreMinimisers.truncated_normal_crps_minimiser">[docs]</a>    <span class="k">def</span> <span class="nf">truncated_normal_crps_minimiser</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">forecast_predictor</span><span class="p">,</span> <span class="n">truth</span><span class="p">,</span> <span class="n">forecast_var</span><span class="p">,</span>
            <span class="n">sqrt_pi</span><span class="p">,</span> <span class="n">predictor_of_mean_flag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Minimisation function to calculate coefficients based on minimising the</span>
<span class="sd">        CRPS for a truncated_normal distribution.</span>

<span class="sd">        Scientific Reference:</span>
<span class="sd">        Thorarinsdottir, T.L. &amp; Gneiting, T., 2010.</span>
<span class="sd">        Probabilistic forecasts of wind speed: Ensemble model</span>
<span class="sd">        output statistics by using heteroscedastic censored regression.</span>
<span class="sd">        Journal of the Royal Statistical Society.</span>
<span class="sd">        Series A: Statistics in Society, 173(2), pp.371-388.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        initial_guess : List</span>
<span class="sd">            List of optimised coefficients.</span>
<span class="sd">            Order of coefficients is [c, d, a, b].</span>
<span class="sd">        forecast_predictor : Numpy array</span>
<span class="sd">            Data to be used as the predictor,</span>
<span class="sd">            either the ensemble mean or the ensemble members.</span>
<span class="sd">        truth : Numpy array</span>
<span class="sd">            Data to be used as truth.</span>
<span class="sd">        forecast_var : Numpy array</span>
<span class="sd">            Ensemble variance data.</span>
<span class="sd">        sqrt_pi : Numpy array</span>
<span class="sd">            Square root of Pi</span>
<span class="sd">        predictor_of_mean_flag : String</span>
<span class="sd">            String to specify the input to calculate the calibrated mean.</span>
<span class="sd">            Currently the ensemble mean (&quot;mean&quot;) and the ensemble members</span>
<span class="sd">            (&quot;members&quot;) are supported as the predictors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : Float</span>
<span class="sd">            Minimum value for the CRPS achieved.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">predictor_of_mean_flag</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">initial_guess</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="n">predictor_of_mean_flag</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;members&quot;</span><span class="p">]:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">initial_guess</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">+</span><span class="p">(</span><span class="n">initial_guess</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

        <span class="n">new_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">truth</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">all_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">new_col</span><span class="p">,</span> <span class="n">forecast_predictor</span><span class="p">))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">all_data</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">initial_guess</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">initial_guess</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">forecast_var</span><span class="p">)</span>
        <span class="n">xz</span> <span class="o">=</span> <span class="p">(</span><span class="n">truth</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">/</span> <span class="n">sigma</span>
        <span class="n">normal_cdf</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">xz</span><span class="p">)</span>
        <span class="n">normal_pdf</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">xz</span><span class="p">)</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">/</span> <span class="n">sigma</span>
        <span class="n">normal_cdf_0</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">normal_cdf_root_two</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">x0</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span>
            <span class="p">(</span><span class="n">sigma</span> <span class="o">/</span> <span class="n">normal_cdf_0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span>
            <span class="p">(</span><span class="n">xz</span> <span class="o">*</span> <span class="n">normal_cdf_0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">normal_cdf</span> <span class="o">+</span> <span class="n">normal_cdf_0</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
             <span class="mi">2</span> <span class="o">*</span> <span class="n">normal_pdf</span> <span class="o">*</span> <span class="n">normal_cdf_0</span> <span class="o">-</span>
             <span class="n">normal_cdf_root_two</span> <span class="o">/</span> <span class="n">sqrt_pi</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mu</span><span class="o">/</span><span class="n">sigma</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mu</span><span class="o">/</span><span class="n">sigma</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BAD_VALUE</span>
        <span class="k">return</span> <span class="n">result</span></div></div>


<div class="viewcode-block" id="EstimateCoefficientsForEnsembleCalibration"><a class="viewcode-back" href="../../../improver.ensemble_calibration.html#improver.ensemble_calibration.ensemble_calibration.EstimateCoefficientsForEnsembleCalibration">[docs]</a><span class="k">class</span> <span class="nc">EstimateCoefficientsForEnsembleCalibration</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class focussing on estimating the optimised coefficients for ensemble</span>
<span class="sd">    calibration.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Logical flag for whether initial guess estimates for the coefficients</span>
    <span class="c1"># will be estimated using linear regression i.e.</span>
    <span class="c1"># ESTIMATE_COEFFICIENTS_FROM_LINEAR_MODEL_FLAG = True, or whether default</span>
    <span class="c1"># values will be used instead i.e.</span>
    <span class="c1"># ESTIMATE_COEFFICIENTS_FROM_LINEAR_MODEL_FLAG = False.</span>
    <span class="n">ESTIMATE_COEFFICIENTS_FROM_LINEAR_MODEL_FLAG</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distribution</span><span class="p">,</span> <span class="n">desired_units</span><span class="p">,</span>
                 <span class="n">predictor_of_mean_flag</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an ensemble calibration plugin that, for Nonhomogeneous Gaussian</span>
<span class="sd">        Regression, calculates coefficients based on historical forecasts and</span>
<span class="sd">        applies the coefficients to the current forecast.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        distribution : String</span>
<span class="sd">            Name of distribution. Assume that the current forecast can be</span>
<span class="sd">            represented using this distribution.</span>
<span class="sd">        desired_units : String or cf_units.Unit</span>
<span class="sd">            The unit that you would like the calibration to be undertaken in.</span>
<span class="sd">            The current forecast, historical forecast and truth will be</span>
<span class="sd">            converted as required.</span>
<span class="sd">        predictor_of_mean_flag : String</span>
<span class="sd">            String to specify the input to calculate the calibrated mean.</span>
<span class="sd">            Currently the ensemble mean (&quot;mean&quot;) and the ensemble members</span>
<span class="sd">            (&quot;members&quot;) are supported as the predictors.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="n">distribution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">desired_units</span> <span class="o">=</span> <span class="n">desired_units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predictor_of_mean_flag</span> <span class="o">=</span> <span class="n">predictor_of_mean_flag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minimiser</span> <span class="o">=</span> <span class="n">ContinuousRankedProbabilityScoreMinimisers</span><span class="p">()</span>

        <span class="kn">import</span> <span class="nn">imp</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">statsmodels_found</span> <span class="o">=</span> <span class="n">imp</span><span class="o">.</span><span class="n">find_module</span><span class="p">(</span><span class="s1">&#39;statsmodels&#39;</span><span class="p">)</span>
            <span class="n">statsmodels_found</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="kn">import</span> <span class="nn">statsmodels.api</span> <span class="k">as</span> <span class="nn">sm</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sm</span> <span class="o">=</span> <span class="n">sm</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="n">statsmodels_found</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">predictor_of_mean_flag</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;members&quot;</span><span class="p">]:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;The statsmodels can not be imported. &quot;</span>
                    <span class="s2">&quot;Will not be able to calculate an initial guess from &quot;</span>
                    <span class="s2">&quot;the individual ensemble members. &quot;</span>
                    <span class="s2">&quot;A default initial guess will be used without &quot;</span>
                    <span class="s2">&quot;estimating coefficients from a linear model.&quot;</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">statsmodels_found</span> <span class="o">=</span> <span class="n">statsmodels_found</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;&lt;EstimateCoefficientsForEnsembleCalibration: &#39;</span>
                  <span class="s1">&#39;distribution: </span><span class="si">{}</span><span class="s1">;&#39;</span> <span class="o">+</span>
                  <span class="s1">&#39;desired_units: </span><span class="si">{}</span><span class="s1">&gt;&#39;</span> <span class="o">+</span>
                  <span class="s1">&#39;predictor_of_mean_flag: </span><span class="si">{}</span><span class="s1">&gt;&#39;</span> <span class="o">+</span>
                  <span class="s1">&#39;minimiser: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">desired_units</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predictor_of_mean_flag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimiser</span><span class="p">)</span>

<div class="viewcode-block" id="EstimateCoefficientsForEnsembleCalibration.compute_initial_guess"><a class="viewcode-back" href="../../../improver.ensemble_calibration.html#improver.ensemble_calibration.ensemble_calibration.EstimateCoefficientsForEnsembleCalibration.compute_initial_guess">[docs]</a>    <span class="k">def</span> <span class="nf">compute_initial_guess</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">truth</span><span class="p">,</span> <span class="n">forecast_predictor</span><span class="p">,</span> <span class="n">predictor_of_mean_flag</span><span class="p">,</span>
            <span class="n">estimate_coefficients_from_linear_model_flag</span><span class="p">,</span> <span class="n">no_of_members</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to compute initial guess of the a and beta components of the</span>
<span class="sd">        EMOS coefficients by linear regression of the forecast predictor</span>
<span class="sd">        and the truth, if requested. Otherwise, default values for a and b</span>
<span class="sd">        will be used.</span>

<span class="sd">        Default values have been chosen based on Figure 8 in the</span>
<span class="sd">        ensemble calibration documentation in</span>
<span class="sd">        https://exxreldocs:8099/display/TEPPV/Science+Plugin+Documents</span>
<span class="sd">        or</span>
<span class="sd">        http://www-nwp/~gevans/reports/EMOS_report_20170327.pdf</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        truth : Iris cube</span>
<span class="sd">            Cube containing the field, which will be used as truth.</span>
<span class="sd">        forecast_predictor : Iris cube</span>
<span class="sd">            Cube containing the fields to be used as the predictor,</span>
<span class="sd">            either the ensemble mean or the ensemble members.</span>
<span class="sd">        predictor_of_mean_flag : String</span>
<span class="sd">            String to specify the input to calculate the calibrated mean.</span>
<span class="sd">            Currently the ensemble mean (&quot;mean&quot;) and the ensemble members</span>
<span class="sd">            (&quot;members&quot;) are supported as the predictors.</span>
<span class="sd">        estimate_coefficients_from_linear_model_flag : Logical</span>
<span class="sd">            Flag whether coefficients should be estimated from</span>
<span class="sd">            the linear regression, or static estimates should be used.</span>
<span class="sd">        no_of_members : Int</span>
<span class="sd">            Number of members, if ensemble members are to be used as</span>
<span class="sd">            predictors. Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        initial_guess : List</span>
<span class="sd">            List of coefficients to be used as initial guess.</span>
<span class="sd">            Order of coefficients is [c, d, a, b].</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">predictor_of_mean_flag</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">estimate_coefficients_from_linear_model_flag</span><span class="p">):</span>
            <span class="n">initial_guess</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">predictor_of_mean_flag</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;members&quot;</span><span class="p">]</span> <span class="ow">and</span>
              <span class="ow">not</span> <span class="n">estimate_coefficients_from_linear_model_flag</span><span class="p">):</span>
            <span class="n">initial_guess</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">no_of_members</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">estimate_coefficients_from_linear_model_flag</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">predictor_of_mean_flag</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]:</span>
                <span class="c1"># Find all values that are not NaN.</span>
                <span class="n">truth_not_nan</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">truth</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
                <span class="n">forecast_not_nan</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">forecast_predictor</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
                <span class="n">combined_not_nan</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">row_stack</span><span class="p">([</span><span class="n">truth_not_nan</span><span class="p">,</span> <span class="n">forecast_not_nan</span><span class="p">]),</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">combined_not_nan</span><span class="p">):</span>
                    <span class="n">gradient</span><span class="p">,</span> <span class="n">intercept</span> <span class="o">=</span> <span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gradient</span><span class="p">,</span> <span class="n">intercept</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">stats</span><span class="o">.</span><span class="n">linregress</span><span class="p">(</span>
                            <span class="n">forecast_predictor</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span>
                                <span class="n">combined_not_nan</span><span class="p">],</span>
                            <span class="n">truth</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">combined_not_nan</span><span class="p">]))</span>
                <span class="n">initial_guess</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">intercept</span><span class="p">,</span> <span class="n">gradient</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">predictor_of_mean_flag</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;members&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">statsmodels_found</span><span class="p">:</span>
                    <span class="n">truth_data</span> <span class="o">=</span> <span class="n">truth</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="n">forecast_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="n">convert_cube_data_to_2d</span><span class="p">(</span>
                            <span class="n">forecast_predictor</span><span class="p">,</span> <span class="n">transpose</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
                    <span class="c1"># Find all values that are not NaN.</span>
                    <span class="n">truth_not_nan</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">truth_data</span><span class="p">)</span>
                    <span class="n">forecast_not_nan</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">forecast_data</span><span class="p">)</span>
                    <span class="n">combined_not_nan</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">row_stack</span><span class="p">([</span><span class="n">truth_not_nan</span><span class="p">,</span> <span class="n">forecast_not_nan</span><span class="p">]),</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sm</span><span class="o">.</span><span class="n">add_constant</span><span class="p">(</span>
                        <span class="n">forecast_data</span><span class="p">[:,</span> <span class="n">combined_not_nan</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                    <span class="n">est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sm</span><span class="o">.</span><span class="n">OLS</span><span class="p">(</span><span class="n">truth_data</span><span class="p">[</span><span class="n">combined_not_nan</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
                    <span class="n">intercept</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">gradient</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="n">initial_guess</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">intercept</span><span class="p">]</span><span class="o">+</span><span class="n">gradient</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">initial_guess</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">no_of_members</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">initial_guess</span></div>

<div class="viewcode-block" id="EstimateCoefficientsForEnsembleCalibration.estimate_coefficients_for_ngr"><a class="viewcode-back" href="../../../improver.ensemble_calibration.html#improver.ensemble_calibration.ensemble_calibration.EstimateCoefficientsForEnsembleCalibration.estimate_coefficients_for_ngr">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_coefficients_for_ngr</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">current_forecast</span><span class="p">,</span> <span class="n">historic_forecast</span><span class="p">,</span> <span class="n">truth</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Using Nonhomogeneous Gaussian Regression/Ensemble Model Output</span>
<span class="sd">        Statistics, estimate the required coefficients from historical</span>
<span class="sd">        forecasts.</span>

<span class="sd">        The main contents of this method is:</span>
<span class="sd">        1. Metadata checks to ensure that the current forecast, historic</span>
<span class="sd">           forecast and truth exist in a form that can be processed.</span>
<span class="sd">        2. Loop through times within the concatenated current forecast cube.</span>
<span class="sd">           a. Extract the desired forecast period from the historic forecasts</span>
<span class="sd">              to match the current forecasts. Apply unit conversion to ensure</span>
<span class="sd">              that historic forecasts have the desired units for calibration.</span>
<span class="sd">           b. Extract the relevant truth to co-incide with the time within</span>
<span class="sd">              the historic forecasts. Apply unit conversion to ensure</span>
<span class="sd">              that the truth has the desired units for calibration.</span>
<span class="sd">           c. Calculate mean and variance.</span>
<span class="sd">           d. Calculate initial guess at coefficient values by performing a</span>
<span class="sd">              linear regression, if requested, otherwise default values are</span>
<span class="sd">              used.</span>
<span class="sd">           e. Perform minimisation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        current_forecast : Iris Cube or CubeList</span>
<span class="sd">            The cube containing the current forecast.</span>
<span class="sd">        historical_forecast : Iris Cube or CubeList</span>
<span class="sd">            The cube or cubelist containing the historical forecasts used for</span>
<span class="sd">            calibration.</span>
<span class="sd">        truth : Iris Cube or CubeList</span>
<span class="sd">            The cube or cubelist containing the truth used for calibration.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        optimised_coeffs : Dictionary</span>
<span class="sd">            Dictionary containing a list of the optimised coefficients</span>
<span class="sd">            for each date.</span>
<span class="sd">        coeff_names : List</span>
<span class="sd">            The name of each coefficient.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">convert_to_cubelist</span><span class="p">(</span><span class="n">cubes</span><span class="p">,</span> <span class="n">cube_type</span><span class="o">=</span><span class="s2">&quot;forecast&quot;</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Convert cube to cubelist, if necessary.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            cubes : Iris Cube or Iris CubeList</span>
<span class="sd">                Cube to be converted to CubeList.</span>
<span class="sd">            cube_type : String</span>
<span class="sd">                String to describe the cube, which is being converted to a</span>
<span class="sd">                CubeList.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cubes</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">CubeList</span><span class="p">):</span>
                <span class="n">cubes</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">CubeList</span><span class="p">([</span><span class="n">cubes</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">cube</span> <span class="ow">in</span> <span class="n">cubes</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The input data within the </span><span class="si">{}</span><span class="s2"> &quot;</span>
                           <span class="s2">&quot;is not an Iris Cube.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cube_type</span><span class="p">))</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cubes</span>

        <span class="c1"># Ensure predictor_of_mean_flag is valid.</span>
        <span class="n">check_predictor_of_mean_flag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predictor_of_mean_flag</span><span class="p">)</span>

        <span class="c1"># Setting default values for optimised_coeffs and coeff_names.</span>
        <span class="n">optimised_coeffs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">coeff_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;gamma&quot;</span><span class="p">,</span> <span class="s2">&quot;delta&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">]</span>

        <span class="c1"># Set default values for whether there are NaN values within the</span>
        <span class="c1"># initial guess.</span>
        <span class="n">nan_in_initial_guess</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="p">[</span><span class="n">current_forecast</span><span class="p">,</span> <span class="n">historic_forecast</span><span class="p">,</span>
                    <span class="n">truth</span><span class="p">]:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">CubeList</span><span class="p">)):</span>
                <span class="n">current_forecast_cubes</span> <span class="o">=</span> <span class="n">current_forecast</span>
                <span class="n">historic_forecast_cubes</span> <span class="o">=</span> <span class="n">historic_forecast</span>
                <span class="n">truth_cubes</span> <span class="o">=</span> <span class="n">truth</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not a Cube or CubeList.&quot;</span>
                       <span class="s2">&quot;Returning default values for optimised_coeffs </span><span class="si">{}</span><span class="s2"> &quot;</span>
                       <span class="s2">&quot;and coeff_names </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                           <span class="n">var</span><span class="p">,</span> <span class="n">optimised_coeffs</span><span class="p">,</span> <span class="n">coeff_names</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">optimised_coeffs</span><span class="p">,</span> <span class="n">coeff_names</span>

        <span class="n">current_forecast_cubes</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">convert_to_cubelist</span><span class="p">(</span>
                <span class="n">current_forecast_cubes</span><span class="p">,</span> <span class="n">cube_type</span><span class="o">=</span><span class="s2">&quot;current forecast&quot;</span><span class="p">))</span>
        <span class="n">historic_forecast_cubes</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">convert_to_cubelist</span><span class="p">(</span>
                <span class="n">historic_forecast_cubes</span><span class="p">,</span> <span class="n">cube_type</span><span class="o">=</span><span class="s2">&quot;historic forecast&quot;</span><span class="p">))</span>
        <span class="n">truth_cubes</span> <span class="o">=</span> <span class="n">convert_to_cubelist</span><span class="p">(</span><span class="n">truth_cubes</span><span class="p">,</span> <span class="n">cube_type</span><span class="o">=</span><span class="s2">&quot;truth&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">current_forecast_cubes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">historic_forecast_cubes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">truth_cubes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Insufficient input data present to estimate &quot;</span>
                   <span class="s2">&quot;coefficients using NGR. &quot;</span>
                   <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Number of current_forecast_cubes: </span><span class="si">{}</span><span class="s2">&quot;</span>
                   <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Number of historic_forecast_cubes: </span><span class="si">{}</span><span class="s2">&quot;</span>
                   <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Number of truth_cubes: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                       <span class="nb">len</span><span class="p">(</span><span class="n">current_forecast_cubes</span><span class="p">),</span>
                       <span class="nb">len</span><span class="p">(</span><span class="n">historic_forecast_cubes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">truth_cubes</span><span class="p">)))</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">optimised_coeffs</span><span class="p">,</span> <span class="n">coeff_names</span>

        <span class="n">rename_coordinate</span><span class="p">(</span>
            <span class="n">current_forecast_cubes</span><span class="p">,</span> <span class="s2">&quot;ensemble_member_id&quot;</span><span class="p">,</span> <span class="s2">&quot;realization&quot;</span><span class="p">)</span>
        <span class="n">rename_coordinate</span><span class="p">(</span>
            <span class="n">historic_forecast_cubes</span><span class="p">,</span> <span class="s2">&quot;ensemble_member_id&quot;</span><span class="p">,</span> <span class="s2">&quot;realization&quot;</span><span class="p">)</span>

        <span class="n">current_forecast_cubes</span> <span class="o">=</span> <span class="n">concatenate_cubes</span><span class="p">(</span>
            <span class="n">current_forecast_cubes</span><span class="p">)</span>
        <span class="n">historic_forecast_cubes</span> <span class="o">=</span> <span class="n">concatenate_cubes</span><span class="p">(</span>
            <span class="n">historic_forecast_cubes</span><span class="p">)</span>
        <span class="n">truth_cubes</span> <span class="o">=</span> <span class="n">concatenate_cubes</span><span class="p">(</span><span class="n">truth_cubes</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">current_forecast_cube</span> <span class="ow">in</span> <span class="n">current_forecast_cubes</span><span class="o">.</span><span class="n">slices_over</span><span class="p">(</span>
                <span class="s2">&quot;time&quot;</span><span class="p">):</span>
            <span class="n">date</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">num2date</span><span class="p">(</span>
                <span class="n">current_forecast_cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="p">,</span>
                <span class="n">current_forecast_cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">current_forecast_cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">calendar</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Extract desired forecast_period from historic_forecast_cubes.</span>
            <span class="n">forecast_period_constr</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span>
                <span class="n">forecast_period</span><span class="o">=</span><span class="n">current_forecast_cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span>
                    <span class="s2">&quot;forecast_period&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="n">historic_forecast_cube</span> <span class="o">=</span> <span class="n">historic_forecast_cubes</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span>
                <span class="n">forecast_period_constr</span><span class="p">)</span>

            <span class="c1"># Extract truth matching the time of the historic forecast.</span>
            <span class="n">truth_constr</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span>
                <span class="n">forecast_reference_time</span><span class="o">=</span><span class="n">historic_forecast_cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span>
                    <span class="s2">&quot;time&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="n">truth_cube</span> <span class="o">=</span> <span class="n">truth_cubes</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">truth_constr</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">truth_cube</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Unable to calibrate for the time points </span><span class="si">{}</span><span class="s2"> &quot;</span>
                       <span class="s2">&quot;as no truth data is available.&quot;</span>
                       <span class="s2">&quot;Moving on to try to calibrate &quot;</span>
                       <span class="s2">&quot;next time point.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                           <span class="n">historic_forecast_cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Make sure inputs have the same units.</span>
            <span class="n">historic_forecast_cube</span><span class="o">.</span><span class="n">convert_units</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">desired_units</span><span class="p">)</span>
            <span class="n">truth_cube</span><span class="o">.</span><span class="n">convert_units</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">desired_units</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">predictor_of_mean_flag</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]:</span>
                <span class="n">no_of_members</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">forecast_predictor</span> <span class="o">=</span> <span class="n">historic_forecast_cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span>
                    <span class="s2">&quot;realization&quot;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MEAN</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">predictor_of_mean_flag</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;members&quot;</span><span class="p">]:</span>
                <span class="n">no_of_members</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="n">historic_forecast_cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s2">&quot;realization&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
                <span class="n">forecast_predictor</span> <span class="o">=</span> <span class="n">historic_forecast_cube</span>

            <span class="n">forecast_var</span> <span class="o">=</span> <span class="n">historic_forecast_cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span>
                <span class="s2">&quot;realization&quot;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">VARIANCE</span><span class="p">)</span>

            <span class="c1"># Computing initial guess for EMOS coefficients</span>
            <span class="c1"># If no initial guess from a previous iteration, or if there</span>
            <span class="c1"># are NaNs in the initial guess, calculate an initial guess.</span>
            <span class="k">if</span> <span class="s2">&quot;initial_guess&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">()</span> <span class="ow">or</span> <span class="n">nan_in_initial_guess</span><span class="p">:</span>
                <span class="n">initial_guess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_initial_guess</span><span class="p">(</span>
                    <span class="n">truth_cube</span><span class="p">,</span> <span class="n">forecast_predictor</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">predictor_of_mean_flag</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ESTIMATE_COEFFICIENTS_FROM_LINEAR_MODEL_FLAG</span><span class="p">,</span>
                    <span class="n">no_of_members</span><span class="o">=</span><span class="n">no_of_members</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">initial_guess</span><span class="p">)):</span>
                <span class="n">nan_in_initial_guess</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">nan_in_initial_guess</span><span class="p">:</span>
                <span class="c1"># Need to access the x attribute returned by the</span>
                <span class="c1"># minimisation function.</span>
                <span class="n">optimised_coeffs</span><span class="p">[</span><span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">minimiser</span><span class="o">.</span><span class="n">crps_minimiser_wrapper</span><span class="p">(</span>
                        <span class="n">initial_guess</span><span class="p">,</span> <span class="n">forecast_predictor</span><span class="p">,</span>
                        <span class="n">truth_cube</span><span class="p">,</span> <span class="n">forecast_var</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">predictor_of_mean_flag</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span><span class="o">.</span><span class="n">lower</span><span class="p">()))</span>
                <span class="n">initial_guess</span> <span class="o">=</span> <span class="n">optimised_coeffs</span><span class="p">[</span><span class="n">date</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">optimised_coeffs</span><span class="p">[</span><span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_guess</span>

        <span class="k">return</span> <span class="n">optimised_coeffs</span><span class="p">,</span> <span class="n">coeff_names</span></div></div>


<div class="viewcode-block" id="ApplyCoefficientsFromEnsembleCalibration"><a class="viewcode-back" href="../../../improver.ensemble_calibration.html#improver.ensemble_calibration.ensemble_calibration.ApplyCoefficientsFromEnsembleCalibration">[docs]</a><span class="k">class</span> <span class="nc">ApplyCoefficientsFromEnsembleCalibration</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to apply the optimised EMOS coefficients to future dates.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">current_forecast</span><span class="p">,</span> <span class="n">optimised_coeffs</span><span class="p">,</span> <span class="n">coeff_names</span><span class="p">,</span>
            <span class="n">predictor_of_mean_flag</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an ensemble calibration plugin that, for Nonhomogeneous Gaussian</span>
<span class="sd">        Regression, applies coefficients created using on historical forecasts</span>
<span class="sd">        and applies the coefficients to the current forecast.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        current_forecast : Iris Cube or CubeList</span>
<span class="sd">            The Cube or CubeList containing the current forecast.</span>
<span class="sd">        optimised_coeffs : Dictionary</span>
<span class="sd">            Dictionary containing a list of the optimised coefficients</span>
<span class="sd">            for each date.</span>
<span class="sd">        coeff_names : List</span>
<span class="sd">            The name of each coefficient.</span>
<span class="sd">        predictor_of_mean_flag : String</span>
<span class="sd">            String to specify the input to calculate the calibrated mean.</span>
<span class="sd">            Currently the ensemble mean (&quot;mean&quot;) and the ensemble members</span>
<span class="sd">            (&quot;members&quot;) are supported as the predictors.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_forecast</span> <span class="o">=</span> <span class="n">current_forecast</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimised_coeffs</span> <span class="o">=</span> <span class="n">optimised_coeffs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeff_names</span> <span class="o">=</span> <span class="n">coeff_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predictor_of_mean_flag</span> <span class="o">=</span> <span class="n">predictor_of_mean_flag</span>

    <span class="k">def</span> <span class="nf">_find_coords_of_length_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cube</span><span class="p">,</span> <span class="n">add_dimension</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to find all coordinates with a length of 1.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cube : Iris cube</span>
<span class="sd">            Cube</span>
<span class="sd">        add_dimension : Logical</span>
<span class="sd">            Adds a dimension of 0 to each coordinate. A tuple is appended.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        length_one_coords : List or List of tuples</span>
<span class="sd">            List of length one coordinates or list of tuples containing</span>
<span class="sd">            length one coordinates and the dimension.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">length_one_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">cube</span><span class="o">.</span><span class="n">coords</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Find length one coordinates</span>
                <span class="k">if</span> <span class="n">add_dimension</span><span class="p">:</span>
                    <span class="n">length_one_coords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">coord</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">length_one_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">length_one_coords</span>

    <span class="k">def</span> <span class="nf">_separate_length_one_coords_into_aux_and_dim</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">length_one_coords</span><span class="p">,</span> <span class="n">dim_coords</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to separate coordinates into auxiliary and dimension</span>
<span class="sd">        coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        length_one_coords : Iterable of coordinates</span>
<span class="sd">            The coordinates to be checked for length one coordinates.</span>
<span class="sd">        dim_coords : List of coordinates</span>
<span class="sd">            The length one coordinates to be made dimension coordinates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        length_one_coords_for_aux_coords</span>
<span class="sd">            List of length one coordinates to be auxiliary coordinates, i.e.</span>
<span class="sd">            not in the dim_coords list.</span>
<span class="sd">        length_one_coords_for_dim_coords</span>
<span class="sd">            List of length one coordinates to be dimension coordinates,</span>
<span class="sd">            according to dim_coords list.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">length_one_coords_for_aux_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">length_one_coords_for_dim_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">length_one_coords</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="ow">in</span> <span class="n">dim_coords</span><span class="p">:</span>
                <span class="n">length_one_coords_for_dim_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">length_one_coords_for_aux_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">length_one_coords_for_aux_coords</span><span class="p">,</span>
            <span class="n">length_one_coords_for_dim_coords</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_create_coefficient_cube</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">cube</span><span class="p">,</span> <span class="n">optimised_coeffs_at_date</span><span class="p">,</span> <span class="n">coeff_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to create a cube to store the coefficients used in the</span>
<span class="sd">        ensemble calibration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cube : Iterable of coordinates</span>
<span class="sd">            The coordinates to be checked for length one coordinates.</span>
<span class="sd">        optimised_coeffs_at_date : List of coefficients</span>
<span class="sd">            Optimised coefficients for a particular date.</span>
<span class="sd">        coeff_names : List</span>
<span class="sd">            List of coefficient names.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coeff_cubes : Iris cube</span>
<span class="sd">            Cube containing the coefficient value as the data array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">length_one_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_coords_of_length_one</span><span class="p">(</span><span class="n">cube</span><span class="p">)</span>

        <span class="n">length_one_coords_for_aux_coords</span><span class="p">,</span> <span class="n">length_one_coords_for_dim_coords</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_separate_length_one_coords_into_aux_and_dim</span><span class="p">(</span>
                <span class="n">length_one_coords</span><span class="p">))</span>

        <span class="n">coeff_cubes</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">CubeList</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">coeff_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">optimised_coeffs_at_date</span><span class="p">,</span> <span class="n">coeff_names</span><span class="p">):</span>
            <span class="n">cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">(</span>
                <span class="p">[</span><span class="n">coeff</span><span class="p">],</span> <span class="n">long_name</span><span class="o">=</span><span class="n">coeff_name</span><span class="p">,</span> <span class="n">attributes</span><span class="o">=</span><span class="n">cube</span><span class="o">.</span><span class="n">attributes</span><span class="p">,</span>
                <span class="n">aux_coords_and_dims</span><span class="o">=</span><span class="n">length_one_coords_for_aux_coords</span><span class="p">,</span>
                <span class="n">dim_coords_and_dims</span><span class="o">=</span><span class="n">length_one_coords_for_dim_coords</span><span class="p">)</span>
            <span class="n">coeff_cubes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cube</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coeff_cubes</span>

<div class="viewcode-block" id="ApplyCoefficientsFromEnsembleCalibration.apply_params_entry"><a class="viewcode-back" href="../../../improver.ensemble_calibration.html#improver.ensemble_calibration.ensemble_calibration.ApplyCoefficientsFromEnsembleCalibration.apply_params_entry">[docs]</a>    <span class="k">def</span> <span class="nf">apply_params_entry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapping function to calculate the forecast predictor and forecast</span>
<span class="sd">        variance prior to applying coefficients to the current forecast.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        calibrated_forecast_predictor : CubeList</span>
<span class="sd">            CubeList containing both the calibrated version of the ensemble</span>
<span class="sd">            predictor, either the ensemble mean/members.</span>
<span class="sd">        calibrated_forecast_variance : CubeList</span>
<span class="sd">            CubeList containing both the calibrated version of the ensemble</span>
<span class="sd">            variance, either the ensemble mean/members.</span>
<span class="sd">        calibrated_forecast_coefficients : CubeList</span>
<span class="sd">            CubeList containing both the coefficients for calibrating</span>
<span class="sd">            the ensemble.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure predictor_of_mean_flag is valid.</span>
        <span class="n">check_predictor_of_mean_flag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predictor_of_mean_flag</span><span class="p">)</span>

        <span class="n">rename_coordinate</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_forecast</span><span class="p">,</span> <span class="s2">&quot;ensemble_member_id&quot;</span><span class="p">,</span> <span class="s2">&quot;realization&quot;</span><span class="p">)</span>

        <span class="n">current_forecast_cubes</span> <span class="o">=</span> <span class="n">concatenate_cubes</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_forecast</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">predictor_of_mean_flag</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]:</span>
            <span class="n">forecast_predictors</span> <span class="o">=</span> <span class="n">current_forecast_cubes</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span>
                <span class="s2">&quot;realization&quot;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MEAN</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">predictor_of_mean_flag</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;members&quot;</span><span class="p">]:</span>
            <span class="n">forecast_predictors</span> <span class="o">=</span> <span class="n">current_forecast_cubes</span>

        <span class="n">forecast_vars</span> <span class="o">=</span> <span class="n">current_forecast_cubes</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span>
            <span class="s2">&quot;realization&quot;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">VARIANCE</span><span class="p">)</span>

        <span class="p">(</span><span class="n">calibrated_forecast_predictor</span><span class="p">,</span> <span class="n">calibrated_forecast_var</span><span class="p">,</span>
         <span class="n">calibrated_forecast_coefficients</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_params</span><span class="p">(</span>
             <span class="n">forecast_predictors</span><span class="p">,</span> <span class="n">forecast_vars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimised_coeffs</span><span class="p">,</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">coeff_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">predictor_of_mean_flag</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">calibrated_forecast_predictor</span><span class="p">,</span>
                <span class="n">calibrated_forecast_var</span><span class="p">,</span>
                <span class="n">calibrated_forecast_coefficients</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_apply_params</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">forecast_predictors</span><span class="p">,</span> <span class="n">forecast_vars</span><span class="p">,</span> <span class="n">optimised_coeffs</span><span class="p">,</span>
            <span class="n">coeff_names</span><span class="p">,</span> <span class="n">predictor_of_mean_flag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to apply EMOS coefficients to all required dates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        forecast_predictors : Iris cube</span>
<span class="sd">            Cube containing the forecast predictor e.g. ensemble mean</span>
<span class="sd">            or ensemble members.</span>
<span class="sd">        forecast_vars : Iris cube.</span>
<span class="sd">            Cube containing the forecast variance e.g. ensemble variance.</span>
<span class="sd">        optimised_coeffs : List</span>
<span class="sd">            Coefficients for all dates.</span>
<span class="sd">        coeff_names : List</span>
<span class="sd">            Coefficient names.</span>
<span class="sd">        predictor_of_mean_flag : String</span>
<span class="sd">            String to specify the input to calculate the calibrated mean.</span>
<span class="sd">            Currently the ensemble mean (&quot;mean&quot;) and the ensemble members</span>
<span class="sd">            (&quot;members&quot;) are supported as the predictors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        calibrated_forecast_predictor_all_dates : CubeList</span>
<span class="sd">            List of cubes containing the calibrated forecast predictor.</span>
<span class="sd">        calibrated_forecast_var_all_dates : CubeList</span>
<span class="sd">            List of cubes containing the calibrated forecast variance.</span>
<span class="sd">        calibrated_forecast_coefficients_all_dates : CubeList</span>
<span class="sd">            List of cubes containing the coefficients used for calibration.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">calibrated_forecast_predictor_all_dates</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">CubeList</span><span class="p">()</span>
        <span class="n">calibrated_forecast_var_all_dates</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">CubeList</span><span class="p">()</span>
        <span class="n">calibrated_forecast_coefficients_all_dates</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">CubeList</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">forecast_predictor</span><span class="p">,</span> <span class="n">forecast_var</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">forecast_predictors</span><span class="o">.</span><span class="n">slices_over</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">),</span>
                <span class="n">forecast_vars</span><span class="o">.</span><span class="n">slices_over</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)):</span>

            <span class="n">date</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">num2date</span><span class="p">(</span>
                <span class="n">forecast_predictor</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="p">,</span>
                <span class="n">forecast_predictor</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">forecast_predictor</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">calendar</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">with</span> <span class="n">iris</span><span class="o">.</span><span class="n">FUTURE</span><span class="o">.</span><span class="n">context</span><span class="p">(</span><span class="n">cell_datetime_objects</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">constr</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">date</span><span class="p">)</span>
                <span class="n">forecast_predictor_at_date</span> <span class="o">=</span> <span class="n">forecast_predictor</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">constr</span><span class="p">)</span>
                <span class="n">forecast_var_at_date</span> <span class="o">=</span> <span class="n">forecast_var</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">constr</span><span class="p">)</span>

            <span class="c1"># If the coefficients are not available for the date, use the</span>
            <span class="c1"># raw ensemble forecast as the calibrated ensemble forecast.</span>
            <span class="k">if</span> <span class="n">date</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">optimised_coeffs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Ensemble calibration not available &quot;</span>
                       <span class="s2">&quot;for forecasts with start time of </span><span class="si">{}</span><span class="s2">. &quot;</span>
                       <span class="s2">&quot;Coefficients not available&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                           <span class="n">date</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">%H%M&quot;</span><span class="p">)))</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">calibrated_forecast_predictor_at_date</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">forecast_predictor_at_date</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="n">calibrated_forecast_var_at_date</span> <span class="o">=</span> <span class="n">forecast_var_at_date</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">optimised_coeffs</span><span class="p">[</span><span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coeff_names</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="n">coeff_cubes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_coefficient_cube</span><span class="p">(</span>
                    <span class="n">forecast_predictor_at_date</span><span class="p">,</span> <span class="n">optimised_coeffs</span><span class="p">,</span> <span class="n">coeff_names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">optimised_coeffs_at_date</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">optimised_coeffs</span><span class="p">[</span><span class="n">date</span><span class="p">])</span>

                <span class="c1"># Assigning coefficients to coefficient names.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">optimised_coeffs_at_date</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeff_names</span><span class="p">):</span>
                    <span class="n">optimised_coeffs_at_date</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                        <span class="nb">zip</span><span class="p">(</span><span class="n">coeff_names</span><span class="p">,</span> <span class="n">optimised_coeffs_at_date</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">optimised_coeffs_at_date</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeff_names</span><span class="p">):</span>
                    <span class="n">excess_beta</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">optimised_coeffs_at_date</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">coeff_names</span><span class="p">):]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="n">optimised_coeffs_at_date</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">coeff_names</span><span class="p">,</span> <span class="n">optimised_coeffs_at_date</span><span class="p">)))</span>
                    <span class="n">optimised_coeffs_at_date</span><span class="p">[</span><span class="s2">&quot;beta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">optimised_coeffs_at_date</span><span class="p">[</span><span class="s2">&quot;beta&quot;</span><span class="p">]]</span><span class="o">+</span><span class="n">excess_beta</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Number of coefficient names </span><span class="si">{}</span><span class="s2"> with names </span><span class="si">{}</span><span class="s2"> &quot;</span>
                           <span class="s2">&quot;is not equal to the number of &quot;</span>
                           <span class="s2">&quot;optimised_coeffs_at_date values </span><span class="si">{}</span><span class="s2"> &quot;</span>
                           <span class="s2">&quot;with values </span><span class="si">{}</span><span class="s2"> or the number of &quot;</span>
                           <span class="s2">&quot;coefficients is not greater than the &quot;</span>
                           <span class="s2">&quot;number of coefficient names. Can not continue &quot;</span>
                           <span class="s2">&quot;if the number of coefficient names out number &quot;</span>
                           <span class="s2">&quot;the number of coefficients&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                               <span class="nb">len</span><span class="p">(</span><span class="n">coeff_names</span><span class="p">),</span> <span class="n">coeff_names</span><span class="p">,</span>
                               <span class="nb">len</span><span class="p">(</span><span class="n">optimised_coeffs_at_date</span><span class="p">),</span>
                               <span class="n">optimised_coeffs_at_date</span><span class="p">))</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">predictor_of_mean_flag</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">]:</span>
                    <span class="c1"># Calculate predicted mean = a + b*X, where X is the</span>
                    <span class="c1"># raw ensemble mean. In this case, b = beta.</span>
                    <span class="n">beta</span> <span class="o">=</span> <span class="p">[</span><span class="n">optimised_coeffs_at_date</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">],</span>
                            <span class="n">optimised_coeffs_at_date</span><span class="p">[</span><span class="s2">&quot;beta&quot;</span><span class="p">]]</span>
                    <span class="n">forecast_predictor_flat</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">forecast_predictor_at_date</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
                    <span class="n">new_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">forecast_predictor_flat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">all_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">new_col</span><span class="p">,</span> <span class="n">forecast_predictor_flat</span><span class="p">))</span>
                    <span class="n">predicted_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">all_data</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
                    <span class="n">calibrated_forecast_predictor_at_date</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">forecast_predictor_at_date</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">predictor_of_mean_flag</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;members&quot;</span><span class="p">]:</span>
                    <span class="c1"># Calculate predicted mean = a + b*X, where X is the</span>
                    <span class="c1"># raw ensemble mean. In this case, b = beta^2.</span>
                    <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">[[</span><span class="n">optimised_coeffs_at_date</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">]],</span>
                         <span class="n">optimised_coeffs_at_date</span><span class="p">[</span><span class="s2">&quot;beta&quot;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">forecast_predictor_flat</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">convert_cube_data_to_2d</span><span class="p">(</span>
                            <span class="n">forecast_predictor_at_date</span><span class="p">))</span>
                    <span class="n">forecast_var_flat</span> <span class="o">=</span> <span class="n">forecast_var_at_date</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

                    <span class="n">new_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">forecast_var_flat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">all_data</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">new_col</span><span class="p">,</span> <span class="n">forecast_predictor_flat</span><span class="p">)))</span>
                    <span class="n">predicted_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">all_data</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
                    <span class="c1"># Calculate mean of ensemble members, as only the</span>
                    <span class="c1"># calibrated ensemble mean will be returned.</span>
                    <span class="n">calibrated_forecast_predictor_at_date</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">forecast_predictor_at_date</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span>
                            <span class="s2">&quot;realization&quot;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MEAN</span><span class="p">))</span>

                <span class="n">xlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">forecast_predictor_at_date</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
                <span class="n">ylen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">forecast_predictor_at_date</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
                <span class="n">predicted_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">predicted_mean</span><span class="p">,</span> <span class="p">(</span><span class="n">ylen</span><span class="p">,</span> <span class="n">xlen</span><span class="p">))</span>
                <span class="n">calibrated_forecast_predictor_at_date</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">predicted_mean</span>

                <span class="c1"># Calculating the predicted variance, based on the</span>
                <span class="c1"># raw variance S^2, where predicted variance = c + dS^2,</span>
                <span class="c1"># where c = (gamma)^2 and d = (delta)^2</span>
                <span class="n">predicted_var</span> <span class="o">=</span> <span class="p">(</span><span class="n">optimised_coeffs_at_date</span><span class="p">[</span><span class="s2">&quot;gamma&quot;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                                 <span class="n">optimised_coeffs_at_date</span><span class="p">[</span><span class="s2">&quot;delta&quot;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span>
                                 <span class="n">forecast_var_at_date</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

                <span class="n">calibrated_forecast_var_at_date</span> <span class="o">=</span> <span class="n">forecast_var_at_date</span>
                <span class="n">calibrated_forecast_var_at_date</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">predicted_var</span>

                <span class="n">coeff_cubes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_coefficient_cube</span><span class="p">(</span>
                    <span class="n">calibrated_forecast_predictor_at_date</span><span class="p">,</span>
                    <span class="n">optimised_coeffs</span><span class="p">[</span><span class="n">date</span><span class="p">],</span> <span class="n">coeff_names</span><span class="p">)</span>

            <span class="n">calibrated_forecast_predictor_all_dates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">calibrated_forecast_predictor_at_date</span><span class="p">)</span>
            <span class="n">calibrated_forecast_var_all_dates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">calibrated_forecast_var_at_date</span><span class="p">)</span>
            <span class="n">calibrated_forecast_coefficients_all_dates</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">coeff_cubes</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">calibrated_forecast_predictor_all_dates</span><span class="p">,</span>
                <span class="n">calibrated_forecast_var_all_dates</span><span class="p">,</span>
                <span class="n">calibrated_forecast_coefficients_all_dates</span><span class="p">)</span></div>


<div class="viewcode-block" id="EnsembleCalibration"><a class="viewcode-back" href="../../../improver.ensemble_calibration.html#improver.ensemble_calibration.ensemble_calibration.EnsembleCalibration">[docs]</a><span class="k">class</span> <span class="nc">EnsembleCalibration</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plugin to wrap the core EMOS processes:</span>
<span class="sd">    1. Estimate optimised EMOS coefficients from training period.</span>
<span class="sd">    2. Apply optimised EMOS coefficients for future dates.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calibration_method</span><span class="p">,</span> <span class="n">distribution</span><span class="p">,</span> <span class="n">desired_units</span><span class="p">,</span>
                 <span class="n">predictor_of_mean_flag</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an ensemble calibration plugin that, for Nonhomogeneous Gaussian</span>
<span class="sd">        Regression, calculates coefficients based on historical forecasts and</span>
<span class="sd">        applies the coefficients to the current forecast.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        calibration_method : String</span>
<span class="sd">            The calibration method that will be applied.</span>
<span class="sd">            Supported methods are:</span>
<span class="sd">                ensemble model output statistics</span>
<span class="sd">                nonhomogeneous gaussian regression</span>
<span class="sd">            Currently these methods are not supported:</span>
<span class="sd">                logistic regression</span>
<span class="sd">                bayesian model averaging</span>
<span class="sd">        distribution : String</span>
<span class="sd">            The distribution that will be used for calibration. This will be</span>
<span class="sd">            dependent upon the input phenomenon. This has to be supported by</span>
<span class="sd">            the minimisation functions in</span>
<span class="sd">            ContinuousRankedProbabilityScoreMinimisers.</span>
<span class="sd">        desired_units : String or cf_units.Unit</span>
<span class="sd">            The unit that you would like the calibration to be undertaken in.</span>
<span class="sd">            The current forecast, historical forecast and truth will be</span>
<span class="sd">            converted as required.</span>
<span class="sd">        predictor_of_mean_flag : String</span>
<span class="sd">            String to specify the input to calculate the calibrated mean.</span>
<span class="sd">            Currently the ensemble mean (&quot;mean&quot;) and the ensemble members</span>
<span class="sd">            (&quot;members&quot;) are supported as the predictors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calibration_method</span> <span class="o">=</span> <span class="n">calibration_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="n">distribution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">desired_units</span> <span class="o">=</span> <span class="n">desired_units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predictor_of_mean_flag</span> <span class="o">=</span> <span class="n">predictor_of_mean_flag</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;&lt;EnsembleCalibration: &#39;</span> <span class="o">+</span>
                  <span class="s1">&#39;calibration_method: </span><span class="si">{}</span><span class="s1">&#39;</span> <span class="o">+</span>
                  <span class="s1">&#39;distribution: </span><span class="si">{}</span><span class="s1">;&#39;</span> <span class="o">+</span>
                  <span class="s1">&#39;desired_units: </span><span class="si">{}</span><span class="s1">;&#39;</span> <span class="o">+</span>
                  <span class="s1">&#39;predictor_of_mean_flag: </span><span class="si">{}</span><span class="s1">;&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calibration_method</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">desired_units</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predictor_of_mean_flag</span><span class="p">)</span>

<div class="viewcode-block" id="EnsembleCalibration.process"><a class="viewcode-back" href="../../../improver.ensemble_calibration.html#improver.ensemble_calibration.ensemble_calibration.EnsembleCalibration.process">[docs]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_forecast</span><span class="p">,</span> <span class="n">historic_forecast</span><span class="p">,</span> <span class="n">truth</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs ensemble calibration through the following steps:</span>
<span class="sd">        1. Estimate optimised coefficients from training period.</span>
<span class="sd">        2. Apply optimised coefficients to current forecast.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        current_forecast : Iris Cube or CubeList</span>
<span class="sd">            The Cube or CubeList that provides the input forecast for</span>
<span class="sd">            the current cycle.</span>
<span class="sd">        historic_forecast : Iris Cube or CubeList</span>
<span class="sd">            The Cube or CubeList that provides the input historic forecasts for</span>
<span class="sd">            calibration.</span>
<span class="sd">        truth : Iris Cube or CubeList</span>
<span class="sd">            The Cube or CubeList that provides the input truth for calibration</span>
<span class="sd">            with dates matching the historic forecasts.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        *  calibrated_forecast_predictor_and_variance : CubeList</span>
<span class="sd">            CubeList containing the calibrated forecast predictor and</span>
<span class="sd">            calibrated forecast variance.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">format_calibration_method</span><span class="p">(</span><span class="n">calibration_method</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Lowercase input string, and replace underscores with spaces.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">calibration_method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>

        <span class="c1"># Ensure predictor_of_mean_flag is valid.</span>
        <span class="n">check_predictor_of_mean_flag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predictor_of_mean_flag</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">format_calibration_method</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calibration_method</span><span class="p">)</span> <span class="ow">in</span>
            <span class="p">[</span><span class="s2">&quot;ensemble model output statistics&quot;</span><span class="p">,</span>
             <span class="s2">&quot;nonhomogeneous gaussian regression&quot;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">format_calibration_method</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distribution</span><span class="p">)</span> <span class="ow">in</span>
                    <span class="p">[</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span> <span class="s2">&quot;truncated gaussian&quot;</span><span class="p">]):</span>
                <span class="n">ec</span> <span class="o">=</span> <span class="n">EstimateCoefficientsForEnsembleCalibration</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">desired_units</span><span class="p">,</span>
                    <span class="n">predictor_of_mean_flag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">predictor_of_mean_flag</span><span class="p">)</span>
                <span class="n">optimised_coeffs</span><span class="p">,</span> <span class="n">coeff_names</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">ec</span><span class="o">.</span><span class="n">estimate_coefficients_for_ngr</span><span class="p">(</span>
                        <span class="n">current_forecast</span><span class="p">,</span> <span class="n">historic_forecast</span><span class="p">,</span> <span class="n">truth</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Other calibration methods are not available. &quot;</span>
                   <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not available&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                       <span class="n">format_calibration_method</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calibration_method</span><span class="p">)))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">ac</span> <span class="o">=</span> <span class="n">ApplyCoefficientsFromEnsembleCalibration</span><span class="p">(</span>
            <span class="n">current_forecast</span><span class="p">,</span> <span class="n">optimised_coeffs</span><span class="p">,</span> <span class="n">coeff_names</span><span class="p">,</span>
            <span class="n">predictor_of_mean_flag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">predictor_of_mean_flag</span><span class="p">)</span>
        <span class="p">(</span><span class="n">calibrated_forecast_predictor</span><span class="p">,</span> <span class="n">calibrated_forecast_variance</span><span class="p">,</span>
         <span class="n">calibrated_forecast_coefficients</span><span class="p">)</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">apply_params_entry</span><span class="p">()</span>
        <span class="n">calibrated_forecast_predictor_and_variance</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">CubeList</span><span class="p">([</span>
            <span class="n">calibrated_forecast_predictor</span><span class="p">,</span> <span class="n">calibrated_forecast_variance</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">calibrated_forecast_predictor_and_variance</span></div></div>


<div class="viewcode-block" id="GeneratePercentilesFromMeanAndVariance"><a class="viewcode-back" href="../../../improver.ensemble_calibration.html#improver.ensemble_calibration.ensemble_calibration.GeneratePercentilesFromMeanAndVariance">[docs]</a><span class="k">class</span> <span class="nc">GeneratePercentilesFromMeanAndVariance</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plugin focussing on generating percentiles from mean and variance.</span>
<span class="sd">    In combination with the EnsembleReordering plugin, this is Ensemble</span>
<span class="sd">    Copula Coupling.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialise the class.&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_create_cube_with_percentiles</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">percentiles</span><span class="p">,</span> <span class="n">template_cube</span><span class="p">,</span> <span class="n">cube_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a cube with a percentile coordinate based on a template cube.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        percentiles : List</span>
<span class="sd">            Ensemble percentiles.</span>
<span class="sd">        template_cube : Iris cube</span>
<span class="sd">            Cube to copy majority of coordinate definitions from.</span>
<span class="sd">        cube_data : Numpy array</span>
<span class="sd">            Data to insert into the template cube.</span>
<span class="sd">            The data is expected to have the shape of</span>
<span class="sd">            percentiles (0th dimension), time (1st dimension),</span>
<span class="sd">            y_coord (2nd dimension), x_coord (3rd dimension).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        String</span>
<span class="sd">            Coordinate name of the matched coordinate.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">percentile_coord</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">DimCoord</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">percentiles</span><span class="p">),</span> <span class="n">long_name</span><span class="o">=</span><span class="s2">&quot;percentile&quot;</span><span class="p">,</span>
            <span class="n">units</span><span class="o">=</span><span class="n">unit</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">),</span> <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;percentile&quot;</span><span class="p">)</span>

        <span class="n">time_coord</span> <span class="o">=</span> <span class="n">template_cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
        <span class="n">y_coord</span> <span class="o">=</span> <span class="n">template_cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
        <span class="n">x_coord</span> <span class="o">=</span> <span class="n">template_cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>

        <span class="n">dim_coords_and_dims</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">percentile_coord</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">time_coord</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="p">(</span><span class="n">y_coord</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="n">x_coord</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>

        <span class="n">frt_coord</span> <span class="o">=</span> <span class="n">template_cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s2">&quot;forecast_reference_time&quot;</span><span class="p">)</span>
        <span class="n">fp_coord</span> <span class="o">=</span> <span class="n">template_cube</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s2">&quot;forecast_period&quot;</span><span class="p">)</span>
        <span class="n">aux_coords_and_dims</span> <span class="o">=</span> <span class="p">[(</span><span class="n">frt_coord</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">fp_coord</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="n">metadata_dict</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">template_cube</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">_asdict</span><span class="p">())</span>

        <span class="n">cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">Cube</span><span class="p">(</span>
            <span class="n">cube_data</span><span class="p">,</span> <span class="n">dim_coords_and_dims</span><span class="o">=</span><span class="n">dim_coords_and_dims</span><span class="p">,</span>
            <span class="n">aux_coords_and_dims</span><span class="o">=</span><span class="n">aux_coords_and_dims</span><span class="p">,</span> <span class="o">**</span><span class="n">metadata_dict</span><span class="p">)</span>
        <span class="n">cube</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="n">template_cube</span><span class="o">.</span><span class="n">attributes</span>
        <span class="n">cube</span><span class="o">.</span><span class="n">cell_methods</span> <span class="o">=</span> <span class="n">template_cube</span><span class="o">.</span><span class="n">cell_methods</span>
        <span class="k">return</span> <span class="n">cube</span>

    <span class="k">def</span> <span class="nf">_mean_and_variance_to_percentiles</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">calibrated_forecast_predictor</span><span class="p">,</span> <span class="n">calibrated_forecast_variance</span><span class="p">,</span>
            <span class="n">percentiles</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function returning percentiles based on the supplied</span>
<span class="sd">        mean and variance. The percentiles are created by assuming a</span>
<span class="sd">        Gaussian distribution and calculating the value of the phenomenon at</span>
<span class="sd">        specific points within the distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        calibrated_forecast_predictor : cube</span>
<span class="sd">            Predictor for the calibrated forecast i.e. the mean.</span>
<span class="sd">        calibrated_forecast_variance : cube</span>
<span class="sd">            Variance for the calibrated forecast.</span>
<span class="sd">        percentiles : List</span>
<span class="sd">            Percentiles at which to calculate the value of the phenomenon at.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        percentile_cube : Iris cube</span>
<span class="sd">            Cube containing the values for the phenomenon at each of the</span>
<span class="sd">            percentiles requested.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">calibrated_forecast_predictor</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">):</span>
            <span class="n">calibrated_forecast_predictor</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">new_axis</span><span class="p">(</span>
                <span class="n">calibrated_forecast_predictor</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">calibrated_forecast_variance</span><span class="o">.</span><span class="n">coord_dims</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">):</span>
            <span class="n">calibrated_forecast_variance</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">new_axis</span><span class="p">(</span>
                <span class="n">calibrated_forecast_variance</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">)</span>

        <span class="n">calibrated_forecast_predictor_data</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">calibrated_forecast_predictor</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">calibrated_forecast_variance_data</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">calibrated_forecast_variance</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">calibrated_forecast_predictor_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                           <span class="nb">len</span><span class="p">(</span><span class="n">percentiles</span><span class="p">)))</span>

        <span class="c1"># Loop over percentiles, and use a normal distribution with the mean</span>
        <span class="c1"># and variance to calculate the values at each percentile.</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">percentile</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">percentiles</span><span class="p">):</span>
            <span class="n">percentile_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                <span class="n">percentile</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">calibrated_forecast_predictor_data</span><span class="p">))</span>
            <span class="n">result</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span>
                <span class="n">percentile_list</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">calibrated_forecast_predictor_data</span><span class="p">,</span>
                <span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">calibrated_forecast_variance_data</span><span class="p">))</span>
            <span class="c1"># If percent point function (PPF) returns NaNs, fill in</span>
            <span class="c1"># mean instead of NaN values. NaN will only be generated if the</span>
            <span class="c1"># variance is zero. Therefore, if the variance is zero, the mean</span>
            <span class="c1"># value is used for all gridpoints with a NaN.</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">calibrated_forecast_variance_data</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">nan_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">result</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]))</span>
                <span class="n">result</span><span class="p">[</span><span class="n">nan_index</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">calibrated_forecast_predictor_data</span><span class="p">[</span><span class="n">nan_index</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">result</span><span class="p">)):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;NaNs are present within the result for the </span><span class="si">{}</span><span class="s2"> &quot;</span>
                       <span class="s2">&quot;percentile. Unable to calculate the percent point &quot;</span>
                       <span class="s2">&quot;function.&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">T</span>

        <span class="n">t_coord</span> <span class="o">=</span> <span class="n">calibrated_forecast_predictor</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
        <span class="n">y_coord</span> <span class="o">=</span> <span class="n">calibrated_forecast_predictor</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
        <span class="n">x_coord</span> <span class="o">=</span> <span class="n">calibrated_forecast_predictor</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">percentiles</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_coord</span><span class="o">.</span><span class="n">points</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_coord</span><span class="o">.</span><span class="n">points</span><span class="p">),</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">x_coord</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>
        <span class="n">percentile_cube</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_cube_with_percentiles</span><span class="p">(</span>
            <span class="n">percentiles</span><span class="p">,</span> <span class="n">calibrated_forecast_predictor</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

        <span class="n">percentile_cube</span><span class="o">.</span><span class="n">cell_methods</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="n">percentile_cube</span>

    <span class="k">def</span> <span class="nf">_create_percentiles</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">no_of_percentiles</span><span class="p">,</span> <span class="n">sampling</span><span class="o">=</span><span class="s2">&quot;quantile&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to create percentiles.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        no_of_percentiles : Int</span>
<span class="sd">            Number of percentiles.</span>
<span class="sd">        sampling : String</span>
<span class="sd">            Type of sampling of the distribution to produce a set of</span>
<span class="sd">            percentiles e.g. quantile or random.</span>
<span class="sd">            Accepted options for sampling are:</span>
<span class="sd">            Quantile: A regular set of equally-spaced percentiles aimed</span>
<span class="sd">                      at dividing a Cumulative Distribution Function into</span>
<span class="sd">                      blocks of equal probability.</span>
<span class="sd">            Random: A random set of ordered percentiles.</span>

<span class="sd">        For further details, Flowerdew, J., 2014.</span>
<span class="sd">        Calibrating ensemble reliability whilst preserving spatial structure.</span>
<span class="sd">        Tellus, Series A: Dynamic Meteorology and Oceanography, 66(1), pp.1-20.</span>
<span class="sd">        Schefzik, R., Thorarinsdottir, T.L. &amp; Gneiting, T., 2013.</span>
<span class="sd">        Uncertainty Quantification in Complex Simulation Models Using Ensemble</span>
<span class="sd">        Copula Coupling.</span>
<span class="sd">        Statistical Science, 28(4), pp.616-640.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        percentiles : List</span>
<span class="sd">            Percentiles calculated using the sampling technique specified.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sampling</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;quantile&quot;</span><span class="p">]:</span>
            <span class="n">percentiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                <span class="mi">1</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">no_of_percentiles</span><span class="p">),</span>
                <span class="n">no_of_percentiles</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">no_of_percentiles</span><span class="p">),</span>
                <span class="n">no_of_percentiles</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">sampling</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;random&quot;</span><span class="p">]:</span>
            <span class="n">percentiles</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no_of_percentiles</span><span class="p">):</span>
                <span class="n">percentiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
                        <span class="mi">1</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">no_of_percentiles</span><span class="p">),</span>
                        <span class="n">no_of_percentiles</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">no_of_percentiles</span><span class="p">)))</span>
            <span class="n">percentiles</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">percentiles</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;The </span><span class="si">{}</span><span class="s2"> sampling option is not yet implemented.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">sampling</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">percentiles</span>

<div class="viewcode-block" id="GeneratePercentilesFromMeanAndVariance.process"><a class="viewcode-back" href="../../../improver.ensemble_calibration.html#improver.ensemble_calibration.ensemble_calibration.GeneratePercentilesFromMeanAndVariance.process">[docs]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calibrated_forecast_predictor_and_variance</span><span class="p">,</span>
                <span class="n">raw_forecast</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate ensemble percentiles from the mean and variance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        calibrated_forecast_predictor_and_variance : Iris CubeList</span>
<span class="sd">            CubeList containing the calibrated forecast predictor and</span>
<span class="sd">            calibrated forecast variance.</span>
<span class="sd">        raw_forecast : Iris Cube or CubeList</span>
<span class="sd">            Cube or CubeList that is expected to be the raw</span>
<span class="sd">            (uncalibrated) forecast.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        calibrated_forecast_percentiles : Iris cube</span>
<span class="sd">            Cube for calibrated percentiles.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">calibrated_forecast_predictor</span><span class="p">,</span> <span class="n">calibrated_forecast_variance</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
             <span class="n">calibrated_forecast_predictor_and_variance</span><span class="p">)</span>

        <span class="n">calibrated_forecast_predictor</span> <span class="o">=</span> <span class="n">concatenate_cubes</span><span class="p">(</span>
            <span class="n">calibrated_forecast_predictor</span><span class="p">)</span>
        <span class="n">calibrated_forecast_variance</span> <span class="o">=</span> <span class="n">concatenate_cubes</span><span class="p">(</span>
            <span class="n">calibrated_forecast_variance</span><span class="p">)</span>
        <span class="n">rename_coordinate</span><span class="p">(</span>
            <span class="n">raw_forecast</span><span class="p">,</span> <span class="s2">&quot;ensemble_member_id&quot;</span><span class="p">,</span> <span class="s2">&quot;realization&quot;</span><span class="p">)</span>
        <span class="n">raw_forecast_members</span> <span class="o">=</span> <span class="n">concatenate_cubes</span><span class="p">(</span><span class="n">raw_forecast</span><span class="p">)</span>

        <span class="n">no_of_percentiles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">raw_forecast_members</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s2">&quot;realization&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>

        <span class="n">percentiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_percentiles</span><span class="p">(</span><span class="n">no_of_percentiles</span><span class="p">)</span>
        <span class="n">calibrated_forecast_percentiles</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mean_and_variance_to_percentiles</span><span class="p">(</span>
                <span class="n">calibrated_forecast_predictor</span><span class="p">,</span>
                <span class="n">calibrated_forecast_variance</span><span class="p">,</span>
                <span class="n">percentiles</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">calibrated_forecast_percentiles</span></div></div>


<div class="viewcode-block" id="EnsembleReordering"><a class="viewcode-back" href="../../../improver.ensemble_calibration.html#improver.ensemble_calibration.ensemble_calibration.EnsembleReordering">[docs]</a><span class="k">class</span> <span class="nc">EnsembleReordering</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plugin for applying the reordering step of Ensemble Copula Coupling,</span>
<span class="sd">    in order to generate ensemble members from percentiles.</span>
<span class="sd">    The percentiles are assumed to be in ascending order.</span>

<span class="sd">    Reference:</span>
<span class="sd">    Schefzik, R., Thorarinsdottir, T.L. &amp; Gneiting, T., 2013.</span>
<span class="sd">    Uncertainty Quantification in Complex Simulation Models Using Ensemble</span>
<span class="sd">    Copula Coupling.</span>
<span class="sd">    Statistical Science, 28(4), pp.616-640.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialise the class.&quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="EnsembleReordering.rank_ecc"><a class="viewcode-back" href="../../../improver.ensemble_calibration.html#improver.ensemble_calibration.ensemble_calibration.EnsembleReordering.rank_ecc">[docs]</a>    <span class="k">def</span> <span class="nf">rank_ecc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calibrated_forecast_percentiles</span><span class="p">,</span> <span class="n">raw_forecast_members</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to apply Ensemble Copula Coupling. This ranks the calibrated</span>
<span class="sd">        forecast members based on a ranking determined from the raw forecast</span>
<span class="sd">        members.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        calibrated_forecast_percentiles : cube</span>
<span class="sd">            Cube for calibrated percentiles. The percentiles are assumed to be</span>
<span class="sd">            in ascending order.</span>
<span class="sd">        raw_forecast_members : cube</span>
<span class="sd">            Cube containing the raw (uncalibrated) forecasts.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Iris cube</span>
<span class="sd">            Cube for calibrated members where at a particular grid point,</span>
<span class="sd">            the ranking of the values within the ensemble matches the ranking</span>
<span class="sd">            from the raw ensemble.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">cube</span><span class="o">.</span><span class="n">CubeList</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">rawfc</span><span class="p">,</span> <span class="n">calfc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">raw_forecast_members</span><span class="o">.</span><span class="n">slices_over</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">),</span>
                <span class="n">calibrated_forecast_percentiles</span><span class="o">.</span><span class="n">slices_over</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)):</span>
            <span class="n">random_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">rawfc</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="c1"># Lexsort returns the indices sorted firstly by the primary key,</span>
            <span class="c1"># the raw forecast data, and secondly by the secondary key, an</span>
            <span class="c1"># array of random data, in order to split tied values randomly.</span>
            <span class="n">sorting_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">random_data</span><span class="p">,</span> <span class="n">rawfc</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># Returns the indices that would sort the array.</span>
            <span class="n">ranking</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sorting_index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># Index the calibrated forecast data using the ranking array.</span>
            <span class="c1"># np.choose allows indexing of a 3d array using a 3d array,</span>
            <span class="n">calfc</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">ranking</span><span class="p">,</span> <span class="n">calfc</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">calfc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">concatenate_cubes</span><span class="p">(</span><span class="n">results</span><span class="p">)</span></div>

<div class="viewcode-block" id="EnsembleReordering.process"><a class="viewcode-back" href="../../../improver.ensemble_calibration.html#improver.ensemble_calibration.ensemble_calibration.EnsembleReordering.process">[docs]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calibrated_forecast</span><span class="p">,</span> <span class="n">raw_forecast</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        calibrated_forecast : Iris Cube or CubeList</span>
<span class="sd">            The cube or cubelist containing the calibrated forecast members.</span>
<span class="sd">        raw_forecast : Iris Cube or CubeList</span>
<span class="sd">            The cube or cubelist containing the raw (uncalibrated) forecast.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        calibrated_forecast_members : cube</span>
<span class="sd">            Cube for a new ensemble member where all points within the dataset</span>
<span class="sd">            are representative of a specified probability threshold across the</span>
<span class="sd">            whole domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rename_coordinate</span><span class="p">(</span>
            <span class="n">raw_forecast</span><span class="p">,</span> <span class="s2">&quot;ensemble_member_id&quot;</span><span class="p">,</span> <span class="s2">&quot;realization&quot;</span><span class="p">)</span>
        <span class="n">calibrated_forecast_percentiles</span> <span class="o">=</span> <span class="n">concatenate_cubes</span><span class="p">(</span>
            <span class="n">calibrated_forecast</span><span class="p">,</span>
            <span class="n">coords_to_slice_over</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;percentile&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">])</span>
        <span class="n">raw_forecast_members</span> <span class="o">=</span> <span class="n">concatenate_cubes</span><span class="p">(</span><span class="n">raw_forecast</span><span class="p">)</span>
        <span class="n">calibrated_forecast_members</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank_ecc</span><span class="p">(</span>
            <span class="n">calibrated_forecast_percentiles</span><span class="p">,</span> <span class="n">raw_forecast_members</span><span class="p">)</span>
        <span class="n">rename_coordinate</span><span class="p">(</span>
            <span class="n">calibrated_forecast_members</span><span class="p">,</span> <span class="s2">&quot;percentile&quot;</span><span class="p">,</span> <span class="s2">&quot;realization&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">calibrated_forecast_members</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Improver  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Met Office.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.8.
    </div>
  </body>
</html>