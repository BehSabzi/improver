#!/usr/bin/env python
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# (C) British Crown Copyright 2017-2018 Met Office.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of the copyright holder nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
"""Script to cutout the desired domain."""

from distutils.spawn import find_executable
import glob
import subprocess

import iris
import numpy as np

from improver.argparser import ArgParser
from improver.utilities.load import load_cube
from improver.utilities.save import save_netcdf

def strings_to_ints(extent):
    return [int(i) for i in extent]


def range_with_endpoint(extent):
    extent = [int(i) for i in extent]
    new_extent = list(np.arange(*extent))
    extent = sorted(list(set(new_extent + extent)))
    return extent


def cutout_values_to_indices(cube, y_extent, x_extent, use_indices):
    if use_indices:
        x_extent = range_with_endpoint(x_extent)
        y_extent = range_with_endpoint(y_extent)
    else:
        y_extent = sorted(strings_to_ints(y_extent))
        x_extent = sorted(strings_to_ints(x_extent))
        y_points = cube.coord(axis="y").points
        y_extent, = np.where(
            np.logical_and(y_points>=y_extent[0], y_points<=y_extent[1]))
        x_points = cube.coord(axis="x").points
        x_extent, = np.where(
            np.logical_and(x_points>=x_extent[0], x_points<=x_extent[1]))
    return y_extent, x_extent


def domain_cutout_with_indices(cube, y_extent, x_extent):
    index = [slice(None)] * cube.ndim
    for axis, extent in zip(["y", "x"], [y_extent, x_extent]):
        dim, = cube.coord_dims(cube.coord(axis=axis))
        index[dim] = extent
    return cube[tuple(index)]


def create_sorted_lambda_constraint(values, coord_name):
    values = [int(i) for i in values]
    values = sorted(values)
    constr = (
        iris.Constraint(
            coord_values={
                coord_name: lambda cell: values[0] <= cell <= values[1]}))
    return constr


def domain_cutout_with_values(
        cube, y_coord_name, x_coord_name, y_extent, x_extent):
    if find_if_any_coordinate_is_circular(cube, [y_coord_name, x_coord_name]):
        cube = cube.intersection(y_coord_name=y_coord, x_coord_name=x_coord)
    else:
        # Sort values into ascending order. Note that they could be passed in
        # as either lowest value first, or lowest value second.
        if y_extent is None:
            y_constr = None
        else:
            y_constr = create_sorted_lambda_constraint(y_extent, y_coord_name)

        if x_extent is None:
            x_constr = None
        else:
            x_constr = create_sorted_lambda_constraint(x_extent, x_coord_name)
        cube = cube.extract(y_constr & x_constr)
    return cube


def find_if_any_coordinate_is_circular(cube, coords):
    coord_has_modulus = False
    for coord in coords:
        if cube.coord(coord).units.modulus:
            coord_has_modulus = True
    return coord_has_modulus


def main():
    """Load in arguments, use ncks to make a cutout and save."""

    parser = ArgParser(
        description='Compute a spatial cutout from an input cube. '
                    'The cutout will be computed by specifying the coordinate '
                    'that will be used to create the cutout and the ')
    parser.add_argument('input_filepath', metavar='INPUT_FILE',
                        help='A path to an input NetCDF file to be processed.'
                             'This could be a wildcarded filepath.')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--output_filepath', metavar='OUTPUT_FILES',
                       help='The output filepath for the processed NetCDF.'
                            'If this option is selected, then the assumption '
                            'is that number of input filepaths will match '
                            'the number of output filepaths.'
                            'This option would therefore support converting '
                            'a single file to an output file with a '
                            'different name.')
    group.add_argument('--output_directory', metavar='OUTPUT_DIRECTORY',
                        help='The output directory for the processed NetCDF.'
                             'If this option is selected, then the assumption '
                             'is that the output filename will be the same '
                             'as the input filename.')
    parser.add_argument('y_coord_name', metavar='Y_COORD_NAME',
                        help='The name of the y coordinate.')
    parser.add_argument('x_coord_name', metavar='X_COORD_NAME',
                        help='The name of the x coordinate.')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--use_indices', action='store_true',
                       help='Specify whether the input values for the '
                            'coordinates are indices or values.')
    group.add_argument('--use_values', action='store_true',
                       help='Specify whether the input values for the '
                            'coordinates are indices or values.')
    parser.add_argument('--x_coord',
                        metavar=('FIRST_LIMIT', 'SECOND_LIMIT'),
                        nargs=2,
                        help='A pair of limits to represent either the '
                             'range for the indices that will be extracted '
                             'e.g. 1 3 to extract from the first index to '
                             'the third index ' 
                             'or the data values that will be used as the '
                             'limits e.g. 10 30 where these limits could '
                             'refer to degrees of longitude.')
    parser.add_argument('--y_coord',
                        metavar=('FIRST_LIMIT', 'SECOND_LIMIT'),
                        nargs=2,
                        help='A pair of limits to represent either the '
                             'range for the indices that will be extracted '
                             'e.g. 1 3 to extract from the first index to '
                             'the third index '
                             'or the data values that will be used as the '
                             'limits e.g. 10 30 where these limits could '
                             'refer to degrees of latitude.')
    parser.add_argument('--force_indices_recalculation', action='store_true',
                        help='If this argument is specified, then the '
                             'y and x extent of the spatial cutout will be '
                             'recalculated for each file, otherwise it will '
                             'be assumed that the input files contain the '
                             'same domain.')
    parser.add_argument('--force_conversion_to_indices', action='store_true',
                        help='')
    parser.add_argument('--ncks_options',
                        help='The list of options for passing to the ncks '
                             'utility. This should be supplied as a string '
                             'of options e.g. "Oh" with no additional hyphens '
                             'or spaces.')
    args = parser.parse_args()

    if args.use_values and args.ncks_options:
        explanation = ("the ncks utility uses indices to create the spatial "
                       "cutout, rather than using the values along the "
                       "selected coordinates.")
        parser.incompatible_options("use_values", "ncks_options", explanation)

    input_files = glob.glob(args.input_filepath)

    if len(input_files) == len([args.output_filepath]):
        output_files = [args.output_filepath]
    else:
        msg = ("If the output_filepath argument is provided, then the number "
               "of input files must match the number of output files.")
        raise ValueError(msg)

    if args.output_directory:
        output_files = []
        for input_file in input_files:
            basename = os.path.basename(input_file)
            output_files.append(os.path.join(args.output_directory, basename))

    if args.use_indices:
        if args.x_coord or args.y_coord:
            if args.x_coord:
                x_coord = args.x_coord
            else:
                x_coord = (0, -1)
            if args.y_coord:
                y_coord = args.y_coord
            else:
                y_coord = (0, -1)
        else:
            msg = ("If indices are to be used to create the cutout, then "
                   "either x coordinate indices, y coordinate indices or "
                   "both must be specified.")
            raise ValueError(msg)

    if args.use_values:
        if args.x_coord or args.y_coord:
            if args.x_coord:
                x_coord = args.x_coord
            else:
                x_coord = None
            if args.y_coord:
                y_coord = args.y_coord
            else:
                y_coord = None
        else:
            msg = ("If values are to be used to create the cutout, then "
                   "either x coordinate values, y coordinate values or "
                   "both must be specified.")
            raise ValueError(msg)

    determine_extent = True
    for input_file, output_file in zip(input_files, output_files):
        if find_executable("ncks"):
            y_constr = "{},{},{}".format(args.y_coord_name, y_coord[0],
                                         y_coord[1])
            x_constr = "{},{},{}".format(args.x_coord_name, x_coord[0],
                                         x_coord[1])
            ncks_options = "-{}".format(args.ncks_options)
            try:
                subprocess.check_call(
                    ["ncks", ncks_options, "-d", y_constr, "-d", x_constr,
                     input_file, output_file])
            except subprocess.CalledProcessError as err:
                print "Caught error"
                msg = ("Error when creating spatial cutout using ncks. "
                       "Error reported is {}".format(err))
                raise ValueError(msg)
        else:
            cube = load_cube(input_file)
            if args.use_indices or args.force_conversion_to_indices:
                if determine_extent or args.different_domains:
                    y_extent, x_extent = (
                        cutout_values_to_indices(
                            cube, y_coord, x_coord, args.use_indices))
                determine_extent = False
                cube = domain_cutout_with_indices(
                    cube, y_extent=y_extent, x_extent=x_extent)
            elif args.use_values:
                cube = domain_cutout_with_values(
                    cube, args.y_coord_name, args.x_coord_name,
                    y_coord, x_coord)
            else:
                msg = ("The spatial cutout uses either indices or values, "
                       "in order to create the spatial cutout. "
                       "Please specify whether you would like the spatial "
                       "cutout to be done in terms of indices or values.")
                raise ValueError(msg)
            save_netcdf(cube, output_file)


if __name__ == "__main__":
    main()
